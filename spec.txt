# CMSM

> Common markup state machine.

Together, the parsing rules described below define what is referred to as a
Common Markup parser.

> This document is currently in progress.
> It is developed jointly with a reference parser:
> [`micromark`](https://github.com/micromark/micromark).
> Contributions are welcome.
>
> Some parts that are still in progress:
>
> *   Adapters
> *   Constructs and extensions
> *   Rewrite flow state machine for updates
> *   Adapter for rich text to check whether emphasis, strong, resource, or
>     reference sequences make up syntax or text
> *   Tokenizing the input stream in reverse (GFM allows `asd@asd.com`, so it
>     seems we need to somehow allow to match the `@` and parse backwards)

## Table of contents

## Background

The common markup parser parses a markup language that is commonly known as
*Markdown*.

The first definition of this format gave several examples of how it worked,
showing input Markdown and output HTML, and came with a reference implementation
(known as Markdown.pl).
When new implementations followed, they mostly followed the first definition,
but deviated from the first implementation, thus making *Markdown* a family of
formats.

Some years later, an attempt was made to standardize the differences between
implementations, by specifying how several edge cases should be handled, through
more input and output examples.
This attempt is known as CommonMark, and many implementations now follow it.

This document defines a more formal format, based on CommonMark, by documenting
how to parse it, instead of documenting input and output examples.
This format is:

*   **strict**, as it defines a state machine, which leaves significantly less
    room for interpretation
*   **agnostic** of HTML, as it does not show examples of output, which lets
    the format be used in new ways
*   **streaming**, because coupling with HTML is what requires a whole stream to
    be buffered as references can resolve to later definitions
*   **complete**, as it defines different types of tokens and how they are
    grouped, which allows the format to be represented as a concrete syntax tree
*   **extensible**, because Markdown is often used in combination with new
    and custom constructs

The origin story of Markdown is similar to that of HTML, which at a time was
also a family of formats.
Through incredible efforts of the WHATWG, a Living Standard was created on how
to parse the format, by defining a state machine.

## Overview

The common markup parser receives input, typically coming over the network or
from the local file system.
This input is represented as characters in the input stream.
Depending on a character, certain effects occur, such as that a new token is
created, one state is switched to another, or something is labelled.
Each line is made up of tokens, such as whitespace, markers, sequences, and
content, and labels, that are both enqueued.
At a certain point, it is known what to do with the queue, whether to discard it
or to use it, in which case there are more effects: groups are closed, opened,
or tokens are changed, for example because it is known that a punctuation marker
should be treated as content.

The parser parses in three stages: flow, content, and text, respectively coming
with their own state machines ([flow state machine][], [content state machine][],
[text state machine][]), and their own adapters.

## Infra

> *This section defines the fundamental concepts upon which this document is
> built.*

A variable is declared in the shared state with `let`, cleared with `unset`, or
changed with `set`, `increment`, or `decrement`.

## Characters

A character is a Unicode code point and is represented as a four to six digit
hexadecimal number, prefixed with `U+` (**\[UNICODE]**).

### Character groups

An [ASCII digit](#) is a character in the inclusive range c:0 to c:9.

An [ASCII upper hex digit](#) a character in the inclusive range c:A to c:F.

An [ASCII lower hex digit](#) a character in the inclusive range c:a to c:f.

An [ASCII hex digit](#) is an [ASCII digit][], [ASCII upper hex digit][], or an
[ASCII lower hex digit][]

An [ASCII upper alpha](#) is a character in the inclusive range c:A to c:Z.

An [ASCII lower alpha](#) is a character in the inclusive range c:a to c:z.

An [ASCII alpha](#) is an [ASCII upper alpha][] or [ASCII lower alpha][].

An [ASCII alphanumeric](#) is an [ASCII digit][] or [ASCII alpha][].

An [ASCII punctuation](#) is a character in the inclusive ranges c:! to c:/, c::
to c:@, c:[ to c:`, or c:{ to c:~.

An [ASCII control](#) is a character in the inclusive range c:NUL to c:US, or
c:DEL.

A [Unicode whitespace](#) is a character in the Unicode `Zs` (Separator, Space)
category, or c:HT, c:LF, c:FF, or c:CR (**\[UNICODE]**).

A [Unicode punctuation](#) is a character in the Unicode `Pc` (Punctuation,
Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`
(Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`
(Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an [ASCII
punctuation][] (**\[UNICODE]**).

An [atext](#) is an [ASCII alphanumeric][], or a character in the inclusive
ranges c:# to c:', c:*, c:+, c:-, c:/, c:=, c:?, c:^ to c:`, or c:{ to c:~
(**\[RFC5322]**).

To [ASCII-lowercase](#) a character, is to increase it by `0x20`, if it an
[ASCII upper alpha][].

To [digitize](#) a character, is to decrease it by `0x30`, `0x37`, or `0x57`,
if it is an [ASCII digit][], [ASCII upper hex digit][], or
[ASCII lower hex digit][], respectively.

### Conceptual characters

A [c:VS](#) character is a conceptual character representing an expanded column
size of a c:HT.

An [c:EOL](#) character is a conceptual character representing a break between
two lines.

An [c:EOF](#) character is a conceptual character representing the end of the
input.

c:VS, c:EOL, and c:EOF are not real characters, but rather represent a character
increase the size of a character, a break between characters, or the lack of any
further characters.

### Tabs

Tabs (c:HT) are typically not expanded into spaces, but do behave as if they
were replaced by spaces with a tab stop of 4 characters.
These character increments are represented by [c:VS] characters.

For the following markup (where `␉` represent a tab):

```markdown
>␉␉a
```

We have the characters: c:>, c:HT, c:VS, c:VS, c:HT, c:VS, c:VS, c:VS, and c:a.

When transforming to an output format, tab characters that are not part of
syntax should be present in the output format.
When the tab itself (and zero or more c:VS characters) are part of syntax, but
some c:VS characters are not, the remaining c:VS characters should be considered
a prefix of the content.

## Input stream

The [input stream](#) consists of the characters pushed into it.

The [input character](#) is the first character in the [input stream][] that has
not yet been consumed.
Initially, the input character is the first character in the input.
When the last character in a line is consumed, the input character is an
[c:EOL][].
Finally, when all character are consumed, the input character is an [c:EOF][].

Any occurrences of c:HT in the [input stream][] is represented by that
character and 0-3 [c:VS][] characters.

### Preprocessing the input stream

The [input stream][] consists of the characters pushed into it as the input is
decoded.

The input, when decoded, is preprocessed and pushed into the input stream as
described in the following algorithm:

*   Let `tabSize` be `4`
*   Let `line` be `1`
*   Let `column` be `1`
*   Let `offset` be `0`
*   *Check*:

    If `offset` is equal to the length of the document, push an c:EOF into the
    [input stream][] representing the lack of any further characters, and return

    Otherwise, if the current character is:

    *   ↪ **c:NUL**

        Increment `offset` by `1`, increment `column` by `1`, push a c:� into
        the [input stream][], and go to the step labelled *check*
    *   ↪ **c:HT**

        Set `count` to the result of calculating `(tabSize - 1) - (column %
        tabSize)`.
        Increment `offset` by `1`, increment `column` by `1`, and push the
        character into the [input stream][].

        Perform the following steps `count` times: increment `column` by `1` and
        push a c:VS into the [input stream][] representing the size increase.

        Finally, go to the step labelled *check*
    *   ↪ **c:LF**

        Increment `offset` by `1`, increment `line` by `1`, and set `column` to
        `1`, push an c:EOL into the [input stream][] representing the character,
        and go to the step labelled *check*
    *   ↪ **c:CR**

        Increment `offset` by `1`, increment `line` by `1`, set `column` to `1`,
        and go to the step labelled *carriage return check*
    *   ↪ **Anything else**

        Increment `offset` by `1`, increment `column` by `1`, push the character
        into the [input stream][], and go to the step labelled *check*
*   *Carriage return check*: if the current character is:

    *   ↪ **c:LF**

        Increment `offset` by `1` and push an c:EOL into the [input stream][]
        representing the previous and current characters
    *   ↪ **Anything else**

        Push an c:EOL into the [input stream][] representing the previous
        character and perform the step labelled *check* on the current character

## Parsing

The states of state machines have certain [effects][], such as that they create
items in the [queue][] (tokens and labels).
The queue is used by tree adapters, in case a valid construct is found.
After using the queue, or when in a bogus construct is found, the queue is
discarded.

The [shared space][] is accessed and mutated by both the tree adapter and the
states of the state machine.

[Construct][]s are registered by hooking a case (one or more characters or
character groups) into certain states.
Upon registration, they define the states used to parse a construct, and the
adapter used to handle the construct.

### Tokenization

Implementations must act as if they use several state machines to tokenize
common markup.
The [flow state machine][] is used to tokenize the line constructs that make up
the structure of the document.
The [content state machine][] is used to tokenize the inline constructs part of
content blocks.
The [text state machine][] is used to tokenize the inline constructs part of
rich or plain text.

Most states [consume][] the [input character][], and either remain in the state
to consume the next character, [reconsume][] the input character in a different
state, or [switch][] to a different state to consume the next character.
States [enqueue][] tokens and labels.

### State

The [shared space](#) is a map of key/value pairs.

The [queue](#) is a list of tokens and labels that are enqueued.
The [current token](#) is the last token in the [queue][].

### Constructs

Markup is parsed per [construct](#).
Some constructs are considered regular (those from CommonMark, such as ATX
headings) and other constructs are extensions (such as YAML frontmatter or MDX).

> ❗️ Define constructs.

### Effects

#### Switch

To [switch](#) to a state is to wait for the next character in the given state.

#### Consume

To [consume](#) the [input character][] affects the [current token][].
Due to the nature of the state machine, it is not possible to consume if there
is no current token.

#### Reconsume

To [reconsume](#) is to [switch][] to the given state, and [consume][] the
[input character][] there.

#### Enqueue

To [enqueue](#) a label is to mark a point between two tokens with a semantic
name, at which point there is no [current token][].

To enqueue a token is to add a new token of the given type to the [queue][],
making it the new [current token][].

#### Ensure

To ensure a token is to enqueue that token if the [current token][] is not of
the given type, and otherwise do nothing.

## Flow state machine

The [flow state machine](#) is used to tokenize the line constructs that make up
the structure of the document (such as headings or thematic breaks) and must
start in the s:initial.

### Initial state

*   ↪ **[c:EOF][]**

    Enqueue an t:end-of-file and emit
*   ↪ **c:LF**\
    ↪ **c:CR**

    Open a g:blank-line, close, and reconsume in the s:line-ending
*   ↪ **c:HT**\
    ↪ **c:SP**

    Enqueue a t:whitespace, consume, and switch to the s:initial-whitespace
*   ↪ **Anything else**

    Reconsume in the s:in-line

### Initial whitespace state

*   ↪ **[c:EOF][]**\
    ↪ **c:LF**\
    ↪ **c:CR**

    Open a g:blank-line, emit, close, and reconsume in the s:line-ending
*   ↪ **c:HT**\
    ↪ **c:SP**\
    ↪ **[c:VS][]**

    Consume
*   ↪ **Anything else**

    Reconsume in the s:in-line

### Line ending state

> **Note**: “Anything else” is not possible.

*   ↪ **[c:EOF][]**

    Enqueue an t:end-of-file and emit
*   ↪ **c:LF**

    Enqueue a t:line-terminator, consume, emit, and switch to the s:initial
*   ↪ **c:CR**

    Enqueue a t:line-terminator, consume, and switch to the s:carriage-return

### Carriage return state

*   ↪ **c:LF**

    Consume, emit, and switch to the s:initial
*   ↪ **Anything else**

    Emit and reconsume in the s:initial

### In line state

If the [stack of continuation][] matches all open groups:

*   And if the [current group][] is an g:html, enqueue a t:content with the
    unused characters of the previous t:whitespace if there is one, and
    reconsume in the s:html-flow-continuation-line
*   And otherwise, if the [current group][] is a g:fenced-code, and either the
    [current token][] is not a t:whitespace, or it is a t:whitespace and its
    unused size is less than four (4), and the [input character][] is the
    [current group][]’s marker, enqueue a t:sequence, consume, and switch to the
    s:fenced-code-close-sequence
*   And otherwise, if the [current group][] is a g:fenced-code, enqueue a
    t:content with the unused characters of the previous t:whitespace if there
    is one, consume, and switch to the s:fenced-code-continuation-line.

Otherwise, if the [current group][] is not a g:content, the previous token is a
t:whitespace, and its unused size is greater than or equal to four (4), add four
to the previous token’s used size, enqueue a t:content with the unused
characters of the previous t:whitespace, consume, and switch to the
s:indented-code-line.

Otherwise, perform the following steps based on the [input character][]:

*   ↪ **c:#**

    Enqueue a t:sequence, consume, and switch to the
    s:atx-heading-open-sequence
*   ↪ **c:***

    Enqueue a t:marker, consume, and switch to the
    s:asterisk-line-asterisk-after
*   ↪ **c:+**

    > ❗️ Todo: Could be a list item or content
*   ↪ **c:-**

    > ❗️ Todo: Could be a list item, thematic break, setext underline secondary,
    > or content
*   ↪ **[ASCII digit][]**

    > ❗️ Todo: Could be a list item or content
*   ↪ **c:<**

    Enqueue a t:content with the unused characters of the previous t:whitespace
    if there is one, consume, and switch to the s:html-flow-open
*   ↪ **c:=**

    If the [current group][] is a g:content, enqueue a t:sequence, consume, and
    switch to the s:setext-heading-underline-equals-to-sequence.

    Otherwise, treat it as per the “anything else” entry below
*   ↪ **c:>**

    Open a g:blockquote, consume, emit, and switch to the s:initial
*   ↪ **c:_**

    > ❗️ Todo: Could be a thematic break or content
*   ↪ **c:`**

    Enqueue a t:sequence, consume, and switch to the
    s:fenced-code-grave-accent-fence-open
*   ↪ **c:~**

    Enqueue a t:sequence, consume, and switch to the
    s:fenced-code-tilde-fence-open
*   ↪ **Anything else**

    Otherwise, enqueue a t:content with the unused characters of the previous
    t:whitespace if there is one, consume, and switch to the
    s:content-continuation

### ATX heading open sequence state

*   ↪ **[c:EOF][]**\
    ↪ **c:LF**\
    ↪ **c:CR**

    Open an g:atx-heading, open an g:atx-heading-fence, emit, close twice, and
    reconsume in the s:line-ending
*   ↪ **c:HT**\
    ↪ **c:SP**

    Enqueue a t:whitespace, consume, and switch to the
    s:atx-heading-open-sequence-after
*   ↪ **c:#**

    If the current token’s size is less than six (6), consume.

    Otherwise, treat it as per the “anything else” entry below
*   ↪ **Anything else**

    Change the [current token][] into a t:content, consume, and switch to the
    s:content-continuation

### ATX heading open sequence after state

*   ↪ **[c:EOF][]**\
    ↪ **c:LF**\
    ↪ **c:CR**

    Open an g:atx-heading, open an g:atx-heading-fence, emit, close twice, and
    reconsume in the s:line-ending
*   ↪ **c:HT**\
    ↪ **c:SP**\
    ↪ **[c:VS][]**

    Consume
*   ↪ **c:#**

    Open an g:atx-heading, open an g:atx-heading-fence, emit, close, enqueue a
    t:sequence, consume, and switch to the s:atx-heading-number-sign-sequence
*   ↪ **Anything else**

    Open an g:atx-heading, open an g:atx-heading-fence, emit, close, enqueue a
    t:content, consume, and switch to the s:atx-heading-content

### ATX heading content state

*   ↪ **[c:EOF][]**\
    ↪ **c:LF**\
    ↪ **c:CR**


    [Process as an ATX heading][] and reconsume in the s:line-ending
*   ↪ **c:HT**\
    ↪ **c:SP**

    Enqueue a t:whitespace, consume, and switch to the s:atx-heading-whitespace
*   ↪ **Anything else**

    Consume

### ATX heading whitespace state

*   ↪ **[c:EOF][]**\
    ↪ **c:LF**\
    ↪ **c:CR**

    [Process as an ATX heading][] and reconsume in the s:line-ending
*   ↪ **c:HT**\
    ↪ **c:SP**\
    ↪ **[c:VS][]**

    Consume
*   ↪ **c:#**

    Enqueue a t:sequence, consume, and switch to the
    s:atx-heading-number-sign-sequence
*   ↪ **Anything else**

    Enqueue a t:content, consume, and switch to the s:atx-heading-content

### ATX heading number sign sequence state

*   ↪ **[c:EOF][]**\
    ↪ **c:LF**\
    ↪ **c:CR**

    [Process as an ATX heading][] and reconsume in the s:line-ending
*   ↪ **c:HT**\
    ↪ **c:SP**

    Enqueue a t:whitespace, consume, and switch to the s:atx-heading-whitespace
*   ↪ **c:#**

    Consume
*   ↪ **Anything else**

    Enqueue a t:content, consume, and switch to the s:atx-heading-content

### Asterisk line asterisk after state

*   ↪ **[c:EOF][]**\
    ↪ **c:LF**\
    ↪ **c:CR**

    [Process as an Asterisk line][] and reconsume in the s:line-ending
*   ↪ **c:HT**\
    ↪ **c:SP**

    Enqueue a t:whitespace, consume, and switch to the
    s:asterisk-line-whitespace
*   ↪ **c:***

    Enqueue a t:marker and consume
*   ↪ **Anything else**

    > ❗️ Todo: handle the input character, reconsume somewhere.

    [Process as an Asterisk line opening][].

### Asterisk line whitespace state

*   ↪ **[c:EOF][]**\
    ↪ **c:LF**\
    ↪ **c:CR**

    [Process as an Asterisk line][] and reconsume in the s:line-ending
*   ↪ **c:HT**\
    ↪ **c:SP**\
    ↪ **[c:VS][]**

    Consume
*   ↪ **c:***

    Enqueue a t:marker, consume, and switch to the
    s:asterisk-line-asterisk-after
*   ↪ **Anything else**

    > ❗️ Todo: handle the input character, reconsume somewhere.

    [Process as an Asterisk line opening][].

### HTML flow open state

*   ↪ **c:!**

    Consume and switch to the s:html-flow-open-markup-declaration
*   ↪ **c:/**

    > ❗️ Todo: Define shared space: `endTag`

    Let `endTag` be `true`, consume, and switch to the
    s:html-flow-open-close-tag-start
*   ↪ **c:?**

    > ❗️ Todo: Define shared space: `kind`

    Let `kind` be `3`, open an g:html, consume, and switch to the
    s:html-flow-continuation-declaration-before
*   ↪ **[ASCII alpha][]**

    > ❗️ Todo: Define shared space: `tagName`

    Append the [ASCII-lowercase][]d character to `tagName`, consume, and switch
    to the s:html-flow-open-tag-name-inside
*   ↪ **Anything else**

    This is not HTML.
    Reconsume in the s:content-continuation

### HTML flow open markup declaration state

*   ↪ **c:-**

    Consume and switch to the s:html-flow-open-comment-inside
*   ↪ **[ASCII upper alpha][]**

    > ❗️ Todo: Define shared space: `kind`

    Let `kind` be `4`, open an g:html, consume, and switch to the
    s:html-flow-continuation-line
*   ↪ **c:[**

    Consume and switch to the s:html-flow-open-character-data-inside
*   ↪ **Anything else**

    This is not HTML.
    Reconsume in the s:content-continuation

### HTML flow open comment inside state

*   ↪ **c:-**

    > ❗️ Todo: Define shared space: `kind`

    Let `kind` be `2`, open an g:html, consume, and switch to the
    s:html-flow-continuation-declaration-before
*   ↪ **Anything else**

    This is not HTML.
    Reconsume in the s:content-continuation

### HTML flow open character data inside state

If the next few characters are:

*   ↪ **`[CDATA[` (the five upper letters “CDATA” with a c:[ before and
    after)**

    > ❗️ Todo: Define shared space: `kind`

    Let `kind` be `5`, open an g:html, consume, and switch to the
    s:html-flow-continuation-line
*   ↪ **Anything else**

    This is not HTML.
    Reconsume in the s:content-continuation

### HTML flow open close tag start state

*   ↪ **[ASCII alpha][]**

    Append the [ASCII-lowercase][]d character to `tagName`, consume, and switch
    to the s:html-flow-open-tag-name-inside
*   ↪ **Anything else**

    This is not HTML.
    Reconsume in the s:content-continuation

### HTML flow open tag name inside state

*   ↪ **[c:EOF][]**\
    ↪ **c:LF**\
    ↪ **c:CR**

    > ❗️ Todo: Define shared space: `tagName`, `endTag`, `kind`

    If `tagName` is a [raw tag][] and `endTag` is not `true`, let `kind` be `1`,
    open an g:html, and reconsume in the s:html-flow-continuation-line.

    Otherwise, if `tagName` is a [basic tag][], let `kind` be `6`, open an
    g:html, and reconsume in the s:html-flow-continuation-line.

    Otherwise, treat it as per the “anything else” entry below
*   ↪ **c:-**\
    ↪ **[ASCII alphanumeric][]**

    > ❗️ Todo: Define shared space: `tagName`

    Append the [ASCII-lowercase][]d character to `tagName` and consume
*   ↪ **c:HT**\
    ↪ **c:SP**

    > ❗️ Todo: Define shared space: `tagName`, `endTag`, `kind`

    If `tagName` is a [raw tag][] and `endTag` is not `true`, let `kind` be `1`,
    open an g:html, consume, and switch to the
    s:html-flow-continuation-line.

    Otherwise, if `tagName` is not a [raw tag][], and the [current group][] is
    not a g:content, consume, and switch to the
    s:html-flow-open-complete-attribute-before.

    Otherwise, treat it as per the “anything else” entry below
*   ↪ **c:/**

    > ❗️ Todo: Define shared space: `tagName`, `endTag`

    If `tagName` is a [basic tag][], consume, and switch to the
    s:html-flow-open-basic-self-closing.

    Otherwise, if `tagName` is not a [basic tag][], `endTag` is not `true`, and
    the [current group][] is not a g:content, consume, and switch to the
    s:html-flow-open-complete-self-closing.

    Otherwise, treat it as per the “anything else” entry below
*   ↪ **c:>**

    > ❗️ Todo: Define shared space: `tagName`, `endTag`, `kind`

    If `tagName` is a [raw tag][] and `endTag` is not `true`, let `kind` be `1`,
    open an g:html, consume, and switch to the
    s:html-flow-continuation-line.

    Otherwise, if `tagName` is a [basic tag][], let `kind` be `6`, open an
    g:html, and reconsume in the s:html-flow-continuation-line.

    Otherwise, if `tagName` is not a [raw tag][], and the [current group][] is
    not a g:content, consume, and switch to the
    s:html-flow-open-complete-tag-after.

    Otherwise, treat it as per the “anything else” entry below
*   ↪ **Anything else**

    This is not HTML.
    Reconsume in the s:content-continuation

### HTML flow open basic self closing state

*   ↪ **c:>**

    > ❗️ Todo: Define shared space: `kind`

    Let `kind` be `6`, open an g:html, consume, and switch to the
    s:html-flow-continuation-line
*   ↪ **Anything else**

    This is not HTML.
    Reconsume in the s:content-continuation

### HTML flow open complete attribute before state

*   ↪ **c:HT**\
    ↪ **c:SP**\
    ↪ **[c:VS][]**

    Consume
*   ↪ **c:/**

    > ❗️ Todo: Define shared space: `endTag`

    If `endTag` is not `true`, consume, and switch to the
    s:html-flow-open-complete-self-closing.

    Otherwise, treat it as per the “anything else” entry below
*   ↪ **c::**\
    ↪ **[ASCII alpha][]**\
    ↪ **c:_**

    > ❗️ Todo: Define shared space: `endTag`

    If `endTag` is not `true`, consume, and switch to the
    s:html-flow-open-complete-attribute-name.

    Otherwise, treat it as per the “anything else” entry below
*   ↪ **c:>**

    > ❗️ Todo: Define shared space: `kind`

    Let `kind` be `7`, open an g:html, consume, and switch to the
    s:html-flow-continuation-line
*   ↪ **Anything else**

    This is not HTML.
    Reconsume in the s:content-continuation

### HTML flow open complete attribute name state

*   ↪ **c:-**\
    ↪ **c:.**\
    ↪ **c::**\
    ↪ **[ASCII alphanumeric][]**\
    ↪ **c:_**

    Consume
*   ↪ **Anything else**

    Reconsume in the s:html-flow-open-complete-attribute-name-after

### HTML flow open complete attribute name after state

*   ↪ **c:HT**\
    ↪ **c:SP**\
    ↪ **[c:VS][]**

    Consume
*   ↪ **c:/**

    > ❗️ Todo: Define shared space: `endTag`

    If `endTag` is not `true`, consume, and switch to the
    s:html-flow-open-complete-self-closing.

    Otherwise, treat it as per the “anything else” entry below
*   ↪ **c:=**

    Consume and switch to the s:html-flow-open-complete-attribute-value-before
*   ↪ **c:>**

    Consume and switch to the s:html-flow-open-complete-tag-after
*   ↪ **Anything else**

    This is not HTML.
    Reconsume in the s:content-continuation

### HTML flow open complete attribute value before state

*   ↪ **[c:EOF][]**\
    ↪ **c:LF**\
    ↪ **c:CR**\
    ↪ **c:<**\
    ↪ **c:=**\
    ↪ **c:>**\
    ↪ **c:`**

    This is not an HTML flow.
    Reconsume in the s:content-continuation
*   ↪ **c:HT**\
    ↪ **c:SP**\
    ↪ **[c:VS][]**

    Consume
*   ↪ **c:"**

    Consume and switch to the
    s:html-flow-open-complete-double-quoted-attribute-value
*   ↪ **c:'**

    Consume and switch to the
    s:html-flow-open-complete-single-quoted-attribute-value
*   ↪ **Anything else**

    Consume and switch to the
    s:html-flow-open-complete-unquoted-attribute-value

### HTML flow open complete double quoted attribute value state

*   ↪ **[c:EOF][]**\
    ↪ **c:LF**\
    ↪ **c:CR**

    This is not HTML.
    Reconsume in the s:content-continuation
*   ↪ **c:"**

    Consume and switch to the s:html-flow-open-complete-attribute-before
*   ↪ **Anything else**

    Consume

### HTML flow open complete single quoted attribute value state

*   ↪ **[c:EOF][]**\
    ↪ **c:LF**\
    ↪ **c:CR**

    This is not HTML.
    Reconsume in the s:content-continuation
*   ↪ **c:'**

    Consume and switch to the s:html-flow-open-complete-attribute-before
*   ↪ **Anything else**

    Consume

### HTML flow open complete unquoted attribute value state

*   ↪ **[c:EOF][]**\
    ↪ **c:HT**\
    ↪ **c:LF**\
    ↪ **c:CR**\
    ↪ **c:SP**\
    ↪ **c:"**\
    ↪ **c:'**\
    ↪ **c:<**\
    ↪ **c:=**\
    ↪ **c:>**\
    ↪ **c:`**

    Reconsume in the s:html-flow-open-complete-attribute-name-after
*   ↪ **Anything else**

    Consume

### HTML flow open complete self closing state

*   ↪ **c:>**

    Consume and switch to the s:html-flow-open-complete-tag-after
*   ↪ **Anything else**

    This is not HTML.
    Reconsume in the s:content-continuation

### HTML flow open complete tag after state

*   ↪ **[c:EOF][]**\
    ↪ **c:HT**\
    ↪ **c:LF**\
    ↪ **c:CR**\
    ↪ **c:SP**

    > ❗️ Todo: Define shared space: `kind`

    Let `kind` be `7`, open an g:html, and reconsume in the
*   ↪ **Anything else**

    This is not HTML.
    Reconsume in the s:content-continuation

### HTML flow continuation line state

*   ↪ **[c:EOF][]**\
    ↪ **c:LF**\
    ↪ **c:CR**

    Open an g:html-line, emit, close, and reconsume in the s:line-ending
*   ↪ **c:-**

    > ❗️ Todo: Define shared space: `kind`

    If `kind` is `7`, consume, and switch to the
    s:html-flow-continuation-comment-inside.

    Otherwise, treat it as per the “anything else” entry below
*   ↪ **c:<**

    > ❗️ Todo: Define shared space: `kind`

    If `kind` is `1`, consume, and switch to the
    s:html-flow-continuation-tag-close.

    Otherwise, treat it as per the “anything else” entry below
*   ↪ **c:>**

    > ❗️ Todo: Define shared space: `kind`

    If `kind` is `4`, consume, and switch to the
    s:html-flow-close-line.

    Otherwise, treat it as per the “anything else” entry below
*   ↪ **c:?**

    > ❗️ Todo: Define shared space: `kind`

    If `kind` is `3`, consume, and switch to the
    s:html-flow-continuation-declaration-before.

    Otherwise, treat it as per the “anything else” entry below
*   ↪ **c:]**

    > ❗️ Todo: Define shared space: `kind`

    If `kind` is `5`, consume, and switch to the
    s:html-flow-continuation-character-data-inside.

    Otherwise, treat it as per the “anything else” entry below
*   ↪ **Anything else**

    Consume

### HTML flow continuation tag close state

*   ↪ **c:/**

    Consume and switch to the s:html-flow-continuation-tag-close-name-inside
*   ↪ **Anything else**

    Reconsume in the s:html-flow-continuation-line

### HTML flow continuation tag close name inside state

*   ↪ **[ASCII alpha][]**

    > ❗️ Todo: Define shared space: `tagName`

    Append the [ASCII-lowercase][]d character to `tagName` and consume
*   ↪ **c:>**

    > ❗️ Todo: Define shared space: `tagName`

    If `tagName` is a [raw tag][], consume, and switch to the
    s:html-flow-close-line.

    Otherwise, treat it as per the “anything else” entry below
*   ↪ **Anything else**

    Reconsume in the s:html-flow-continuation-line

### HTML flow continuation comment inside state

*   ↪ **c:-**

    Consume and switch to the s:html-flow-continuation-declaration-before
*   ↪ **Anything else**

    Reconsume in the s:html-flow-continuation-line

### HTML flow continuation character data inside state

*   ↪ **c:]**

    Consume and switch to the s:html-flow-continuation-declaration-before
*   ↪ **Anything else**

    Reconsume in the s:html-flow-continuation-line

### HTML flow continuation declaration before state

*   ↪ **c:>**

    Consume and switch to the s:html-flow-close-line
*   ↪ **Anything else**

    Reconsume in the s:html-flow-continuation-line

### HTML flow close line state

*   ↪ **[c:EOF][]**\
    ↪ **c:LF**\
    ↪ **c:CR**

    Open an g:html-line, emit, close twice, and reconsume in the s:line-ending
*   ↪ **Anything else**

    Consume

### Setext heading underline equals to sequence state

*   ↪ **[c:EOF][]**\
    ↪ **c:LF**\
    ↪ **c:CR**

    [Process as a Setext primary heading][] and reconsume in the s:line-ending
*   ↪ **c:=**

    Consume
*   ↪ **c:HT**\
    ↪ **c:SP**

    Enqueue a t:whitespace, consume, and switch to the
    s:setext-heading-underline-equals-to-after
*   ↪ **Anything else**

    Turn the [current token][] into a t:content, consume, and switch to the
    s:content-continuation

### Setext heading underline equals to after state

*   ↪ **[c:EOF][]**\
    ↪ **c:LF**\
    ↪ **c:CR**

    [Process as a Setext primary heading][] and reconsume in the s:line-ending
*   ↪ **c:HT**\
    ↪ **c:SP**\
    ↪ **[c:VS][]**

    Consume
*   ↪ **Anything else**

    Turn the previous and  [current token][] into a t:content, consume, and
    switch to the s:content-continuation

### Fenced code grave accent fence open state

*   ↪ **[c:EOF][]**\
    ↪ **c:LF**\
    ↪ **c:CR**

    If the [current token][]’s size is greater than or equal to three (3),
    Open a g:fenced-code, [process as a Fenced code fence][] and reconsume in
    the s:line-ending

    Otherwise, this is not fenced code.
    Turn the [current token][] into a t:content and reconsume in the
    s:content-continuation
*   ↪ **c:`**

    Consume
*   ↪ **c:HT**\
    ↪ **c:SP**

    If the [current token][]’s size is greater than or equal to three (3),
    enqueue a t:whitespace, consume, and switch to the
    s:fenced-code-grave-accent-fence-open-whitespace

    Otherwise, this is not fenced code.
    Turn the [current token][] into a t:content and reconsume in the
    s:content-continuation
*   ↪ **Anything else**

    If the [current token][]’s size is greater than or equal to three (3),
    enqueue a t:content, consume, and switch to the
    s:fenced-code-grave-accent-fence-open-metadata

    Otherwise, this is not fenced code.
    Turn the enqueue, except for the first token if it is a t:whitespace, into a
    t:content and reconsume in the s:content-continuation

### Fenced code grave accent fence open whitespace state

*   ↪ **[c:EOF][]**\
    ↪ **c:LF**\
    ↪ **c:CR**

    Open a g:fenced-code, [process as a Fenced code fence][] and reconsume in
    the s:line-ending
*   ↪ **c:HT**\
    ↪ **c:SP**\
    ↪ **[c:VS]**

    Consume
*   ↪ **c:`**

    This is not fenced code.
    Turn the queue, except for the first token if it is a t:whitespace, into a
    t:content and reconsume in the s:content-continuation
*   ↪ **Anything else**

    Enqueue a t:content, consume, and switch to the
    s:fenced-code-grave-accent-fence-open-metadata

### Fenced code grave accent fence open metadata state

*   ↪ **[c:EOF][]**\
    ↪ **c:LF**\
    ↪ **c:CR**

    Open a g:fenced-code, [process as a Fenced code fence][] and reconsume in
    the s:line-ending
*   ↪ **c:HT**\
    ↪ **c:SP**

    Enqueue a t:whitespace, consume, and switch to the
    s:fenced-code-grave-accent-fence-open-whitespace
*   ↪ **c:`**

    This is not fenced code.
    Turn the queue, except for the first token if it is a t:whitespace, into a
    t:content and reconsume in the s:content-continuation
*   ↪ **Anything else**

    Consume

### Fenced code tilde fence open state

*   ↪ **[c:EOF][]**\
    ↪ **c:LF**\
    ↪ **c:CR**

    If the [current token][]’s size is greater than or equal to three (3), open
    a g:fenced-code, [process as a Fenced code fence][] and reconsume in the
    s:line-ending

    Otherwise, this is not fenced code.
    Turn the [current token][] into a t:content and reconsume in the
    s:content-continuation
*   ↪ **c:~**

    Consume
*   ↪ **c:HT**\
    ↪ **c:SP**

    If the [current token][]’s size is greater than or equal to three (3),
    enqueue a t:whitespace, consume, and switch to the
    s:fenced-code-tilde-fence-open-whitespace

    Otherwise, this is not fenced code.
    Turn the [current token][] into a t:content and reconsume in the
    s:content-continuation
*   ↪ **Anything else**

    If the [current token][]’s size is greater than or equal to three (3),
    enqueue a t:content, consume, and switch to the
    s:fenced-code-tilde-fence-open-metadata

    Otherwise, this is not fenced code.
    Turn the [current token][] into a t:content and reconsume in the
    s:content-continuation

### Fenced code tilde fence open whitespace state

*   ↪ **[c:EOF][]**\
    ↪ **c:LF**\
    ↪ **c:CR**

    Open a g:fenced-code, [process as a Fenced code fence][] and reconsume in
    the s:line-ending
*   ↪ **c:HT**\
    ↪ **c:SP**\
    ↪ **[c:VS]**

    Consume
*   ↪ **Anything else**

    Enqueue a t:content, consume, and switch to the
    s:fenced-code-tilde-fence-open-metadata

### Fenced code tilde fence open metadata state

*   ↪ **[c:EOF][]**\
    ↪ **c:LF**\
    ↪ **c:CR**

    Open a g:fenced-code, [process as a Fenced code fence][] and reconsume in
    the s:line-ending
*   ↪ **c:HT**\
    ↪ **c:SP**

    Enqueue a t:whitespace, consume, and switch to the
    s:fenced-code-tilde-fence-open-whitespace
*   ↪ **Anything else**

    Consume

### Fenced code continuation line state

*   ↪ **[c:EOF][]**\
    ↪ **c:LF**\
    ↪ **c:CR**

    Open a g:fenced-code-line, emit, close, and reconsume in the
    s:line-ending
*   ↪ **Anything else**

    Consume

### Fenced code close sequence state

*   ↪ **[c:EOF][]**\
    ↪ **c:LF**\
    ↪ **c:CR**

    > ❗️ Todo: Define shared space: `sizeOpen`

    If the [current token][]’s size is greater than or equal to `sizeOpen`,
    [process as a Fenced code fence][], close, and reconsume in the
    s:line-ending

    Otherwise, treat it as per the “anything else” entry below
*   ↪ **c:HT**\
    ↪ **c:SP**

    > ❗️ Todo: Define shared space: `sizeOpen`

    If the [current token][]’s size is greater than or equal to `sizeOpen`,
    enqueue a t:whitespace, consume, and switch to the
    s:fenced-code-close-whitespace.

    Otherwise, treat it as per the “anything else” entry below
*   ↪ **c:`**\
    ↪ **c:~**

    If the [input character][] is the [current token][]’s marker, consume.

    Otherwise, treat it as per the “anything else” entry below
*   ↪ **Anything else**

    Turn the [current token][] into a t:content and reconsume in the
    s:fenced-code-continuation-line

### Fenced code close whitespace state

*   ↪ **[c:EOF][]**\
    ↪ **c:LF**\
    ↪ **c:CR**

    [Process as a Fenced code fence][], close, and reconsume in the
    s:line-ending
*   ↪ **c:HT**\
    ↪ **c:SP**\
    ↪ **[c:VS][]**

    Consume
*   ↪ **Anything else**

    Turn the queue, except for the first token if it is a t:whitespace, into a
    t:content and reconsume in the s:fenced-code-continuation-line

### Indented code line state

*   ↪ **[c:EOF][]**\
    ↪ **c:LF**\
    ↪ **c:CR**

    If the current open block is not an g:indented-code, open an
    g:indented-code.

    Open an g:indented-code-line, emit, close, and reconsume in the
    s:line-ending
*   ↪ **Anything else**

    Consume

### Content continuation state

*   ↪ **[c:EOF][]**\
    ↪ **c:LF**\
    ↪ **c:CR**

    If the current open block is not a g:content, open a g:content.

    Open a g:content-line, emit, close, and reconsume in the s:line-ending
*   ↪ **Anything else**

    Consume

## Content state machine

The [content state machine](#) is used to tokenize the inline constructs part of
content blocks in a document (such as regular definitions and phrasing) and must
start in the s:content-start.

### Content start state

> **Hookable**, the regular hooks are:
>
> *   **c:[**: s:definition-label-start

*   ↪ **Anything else**

    Reconsume in the s:phrasing-content

### Content initial state

> **Hookable**, there are no regular hooks.

*   ↪ **Anything else**

    Reconsume in the s:phrasing-content

### Definition label start state

*   ↪ **c:[**

    Enqueue a l:content-definition-start, enqueue a
    l:content-definition-label-start, enqueue a t:marker, consume, enqueue a
    l:content-definition-label-open, and switch to the s:definition-label-before
*   ↪ **Anything else**

    Enqueue a l:nok

### Definition label before state

*   ↪ **[c:EOF][]**

    Enqueue a l:nok
*   ↪ **[c:EOL][]**

    Enqueue an t:end-of-line and consume
*   ↪ **[c:VS][]**\
    ↪ **c:HT**\
    ↪ **c:SP**

    Ensure a t:whitespace and consume
*   ↪ **c:]**

    Enqueue a l:nok
*   ↪ **Anything else**

    Enqueue a t:content, consume, and switch to the s:definition-label-inside

### Definition label inside state

*   ↪ **[c:EOF][]**\
    ↪ **[c:EOL][]**\
    ↪ **[c:VS][]**\
    ↪ **c:HT**\
    ↪ **c:SP**

    Reconsume in the s:definition-label-between
*   ↪ **U+005C BACKSLASH (`\`)**

    Ensure a t:content, consume, and switch to the s:definition-label-escape
*   ↪ **c:]**

    Enqueue a l:content-definition-label-close, enqueue a t:marker, consume,
    enqueue a l:content-definition-label-end, and switch to the
    s:definition-label-after
*   ↪ **Anything else**

    Ensure a t:content and consume

### Definition label between state

*   ↪ **[c:EOF][]**

    Enqueue a l:nok
*   ↪ **[c:EOL][]**

    Enqueue an t:end-of-line and consume
*   ↪ **[c:VS][]**\
    ↪ **c:HT**\
    ↪ **c:SP**

    Ensure a t:whitespace and consume
*   ↪ **Anything else**

    Reconsume in the s:definition-label-inside

### Definition label escape state

*   ↪ **U+005C BACKSLASH (`\`)**\
    ↪ **c:]**

    Consume and switch to the s:definition-label-inside
*   ↪ **Anything else**

    Reconsume in the s:definition-label-inside

### Definition label after state

*   ↪ **c::**

    Enqueue a t:marker, consume, and switch to the
    s:definition-destination-before
*   ↪ **Anything else**

    Enqueue a l:nok

### Definition destination before state

*   ↪ **[c:EOF][]**

    Enqueue a l:nok
*   ↪ **[c:EOL][]**

    Enqueue an t:end-of-line and consume
*   ↪ **[c:VS][]**\
    ↪ **c:HT**\
    ↪ **c:SP**

    Ensure a t:whitespace and consume
*   ↪ **c:<**

    Enqueue a l:content-definition-destination-start, enqueue a t:marker,
    enqueue a l:content-definition-destination-quoted-open, consume, and switch
    to the s:definition-destination-quoted-inside
*   ↪ **[ASCII control][]**

    Enqueue a l:nok
*   ↪ **Anything else**

    Let `balance` be `0`, enqueue a l:content-definition-destination-start,
    enqueue a l:content-definition-destination-unquoted-open, enqueue a
    t:content, and reconsume in the s:definition-destination-unquoted-inside

### Definition destination quoted inside state

*   ↪ **[c:EOF][]**\
    ↪ **[c:EOL][]**\
    ↪ **c:<**

    Enqueue a l:nok
*   ↪ **c:>**

    Enqueue a l:content-definition-destination-quoted-close, enqueue a t:marker,
    consume, enqueue a l:content-definition-destination-end, and switch to the
    s:definition-destination-after
*   ↪ **U+005C BACKSLASH (`\`)**

    Ensure a t:content, consume, and switch to the
    s:definition-destination-quoted-escape
*   ↪ **Anything else**

    Ensure a t:content and consume

### Definition destination quoted escape state

*   ↪ **c:<**\
    ↪ **c:>**\
    ↪ **U+005C BACKSLASH (`\`)**

    Consume and switch to the s:definition-destination-quoted-inside
*   ↪ **Anything else**

    Reconsume in the s:definition-destination-quoted-inside

### Definition destination unquoted inside state

*   ↪ **[c:EOF][]**\
    ↪ **[c:EOL][]**\
    ↪ **[c:VS][]**\
    ↪ **c:HT**\
    ↪ **c:SP**

    Unset `balance`, enqueue a l:content-definition-destination-unquoted-close,
    enqueue a l:content-definition-destination-end, and reconsume in the
    s:definition-title-before
*   ↪ **c:(**

    Increment `balance` by `1`, ensure a t:content, and consume
*   ↪ **c:)**

    If `balance` is `0`, treat it as per the “ASCII control” entry below

    Otherwise, decrement `balance` by `1`, ensure a t:content, and consume
*   ↪ **U+005C BACKSLASH (`\`)**

    Ensure a t:content, consume, and switch to the
    s:definition-destination-unquoted-escape
*   ↪ **[ASCII control][]**

    Unset `balance` and enqueue a l:nok
*   ↪ **Anything else**

    Ensure a t:content and consume

### Definition destination unquoted escape state

*   ↪ **c:(**\
    ↪ **c:)**\
    ↪ **U+005C BACKSLASH (`\`)**

    Consume and switch to the s:definition-destination-unquoted-inside
*   ↪ **Anything else**

    Reconsume in the s:definition-destination-unquoted-inside

### Definition destination after state

*   ↪ **[c:EOF][]**\
    ↪ **[c:EOL][]**\
    ↪ **[c:VS][]**\
    ↪ **c:HT**\
    ↪ **c:SP**

    Reconsume in the s:definition-title-before
*   ↪ **Anything else**

    Enqueue a l:nok

### Definition title before state

*   ↪ **[c:EOL][]**

    Enqueue a l:content-definition-partial, enqueue an t:end-of-line, consume,
    and switch to the s:definition-title-or-label-before
*   ↪ **[c:VS][]**\
    ↪ **c:HT**\
    ↪ **c:SP**

    Ensure a t:whitespace and consume
*   ↪ **c:[**

    Enqueue a l:nok
*   ↪ **Anything else**

    Reconsume in the s:definition-title-or-label-before

### Definition title or label before state

*   ↪ **[c:EOF][]**

    Enqueue a l:content-definition-end and enqueue an t:end-of-file
*   ↪ **[c:EOL][]**

    Enqueue an t:end-of-line and consume
*   ↪ **[c:VS][]**\
    ↪ **c:HT**\
    ↪ **c:SP**

    Ensure a t:whitespace and consume
*   ↪ **c:"**

    Enqueue a l:content-definition-title-start, enqueue a t:marker, consume,
    enqueue a l:content-definition-title-open, and switch to the
    s:definition-title-double-quoted
*   ↪ **c:'**

    Enqueue a l:content-definition-title-start, enqueue a t:marker, consume,
    enqueue a l:content-definition-title-open, and switch to the
    s:definition-title-single-quoted
*   ↪ **c:(**

    Enqueue a l:content-definition-title-start, enqueue a t:marker, consume,
    enqueue a l:content-definition-title-open, and switch to the
    s:definition-title-paren-quoted
*   ↪ **Anything else**

    Reconsume in the s:content-start

### Definition title double quoted state

*   ↪ **[c:EOF][]**\
    ↪ **[c:EOL][]**\
    ↪ **[c:VS][]**\
    ↪ **c:HT**\
    ↪ **c:SP**

    Reconsume in the s:definition-title-double-quoted-between
*   ↪ **c:"**

    Enqueue a l:content-definition-title-close, enqueue a t:marker, consume,
    enqueue a l:content-definition-title-end, and switch to the
    s:definition-title-after
*   ↪ **U+005C BACKSLASH (`\`)**

    Ensure a t:content, consume, and switch to the
    s:definition-title-double-quoted-escape
*   ↪ **Anything else**

    Ensure a t:content and consume

### Definition title double quoted between state

*   ↪ **[c:EOF][]**

    Enqueue a l:nok
*   ↪ **[c:EOL][]**

    Enqueue an t:end-of-line and consume
*   ↪ **[c:VS][]**\
    ↪ **c:HT**\
    ↪ **c:SP**

    Ensure a t:whitespace and consume
*   ↪ **Anything else**

    Reconsume in the s:definition-title-double-quoted

### Definition title double quoted escape state

*   ↪ **c:"**\
    ↪ **U+005C BACKSLASH (`\`)**

    Consume and switch to the s:definition-title-double-quoted
*   ↪ **Anything else**

    Reconsume in the s:definition-title-double-quoted

### Definition title single quoted state

*   ↪ **[c:EOF][]**\
    ↪ **[c:EOL][]**\
    ↪ **[c:VS][]**\
    ↪ **c:HT**\
    ↪ **c:SP**

    Reconsume in the s:definition-title-single-quoted-between
*   ↪ **c:'**

    Enqueue a l:content-definition-title-close, enqueue a t:marker, consume,
    enqueue a l:content-definition-title-end, and switch to the
    s:definition-title-after
*   ↪ **U+005C BACKSLASH (`\`)**

    Ensure a t:content, consume, and switch to the
    s:definition-title-single-quoted-escape
*   ↪ **Anything else**

    Ensure a t:content and consume

### Definition title single quoted between state

*   ↪ **[c:EOF][]**

    Enqueue a l:nok
*   ↪ **[c:EOL][]**

    Enqueue an t:end-of-line and consume
*   ↪ **[c:VS][]**\
    ↪ **c:HT**\
    ↪ **c:SP**

    Ensure a t:whitespace and consume
*   ↪ **Anything else**

    Reconsume in the s:definition-title-single-quoted

### Definition title single quoted escape state

*   ↪ **c:'**\
    ↪ **U+005C BACKSLASH (`\`)**

    Consume and switch to the s:definition-title-single-quoted
*   ↪ **Anything else**

    Reconsume in the s:definition-title-single-quoted

### Definition title paren quoted state

*   ↪ **[c:EOF][]**\
    ↪ **[c:EOL][]**\
    ↪ **[c:VS][]**\
    ↪ **c:HT**\
    ↪ **c:SP**

    Reconsume in the s:definition-title-paren-quoted-between
*   ↪ **c:)**

    Enqueue a l:content-definition-title-close, enqueue a t:marker, consume,
    enqueue a l:content-definition-title-end, and switch to the
    s:definition-title-after
*   ↪ **U+005C BACKSLASH (`\`)**

    Ensure a t:content, consume, and switch to the
    s:definition-title-paren-quoted-escape
*   ↪ **Anything else**

    Ensure a t:content and consume

### Definition title paren quoted between state

*   ↪ **[c:EOF][]**

    Enqueue a l:nok
*   ↪ **[c:EOL][]**

    Enqueue an t:end-of-line and consume
*   ↪ **[c:VS][]**\
    ↪ **c:HT**\
    ↪ **c:SP**

    Ensure a t:whitespace and consume
*   ↪ **Anything else**

    Reconsume in the s:definition-title-paren-quoted

### Definition title paren quoted escape state

*   ↪ **c:)**\
    ↪ **U+005C BACKSLASH (`\`)**

    Consume and switch to the s:definition-title-paren-quoted
*   ↪ **Anything else**

    Reconsume in the s:definition-title-paren-quoted

### Definition title after state

*   ↪ **[c:EOF][]**

    Enqueue a l:content-definition-end and enqueue an t:end-of-file
*   ↪ **[c:EOL][]**

    Enqueue a l:content-definition-end, enqueue an t:end-of-line, consume, and
    switch to the s:content-start
*   ↪ **[c:VS][]**\
    ↪ **c:HT**\
    ↪ **c:SP**

    Ensure a t:whitespace and consume
*   ↪ **Anything else**

    Enqueue a l:nok

### Phrasing content state

*   ↪ **[c:EOF][]**

    Enqueue an t:end-of-file
*   ↪ **[c:EOL][]**

    Enqueue an t:end-of-line, consume, and switch to the s:content-initial

## Text state machine

The [text state machine](#) is used to tokenize the inline constructs part of
rich text (such as resources and emphasis) or plain text (as in character
escapes or character references) in a document and must start in the
s:after-whitespace.

### After whitespace state

If text is parsed as plain text, this state should act as per the s:plain-text.
Otherwise:

*   ↪ **c:***

    Let `delimiterRunBefore` be `'whitespace'`, let `delimiterRunAfter` be
    `null`, enqueue a t:sequence, consume, and switch to the s:emphasis-asterisk
*   ↪ **c:_**

    Let `delimiterRunBefore` be `'whitespace'`, let `delimiterRunAfter` be
    `null`, enqueue a t:sequence, consume, and switch to the
    s:emphasis-underscore
*   ↪ **Anything else**

    Reconsume in the s:text

### After punctuation state

If text is parsed as plain text, this state should act as per the s:plain-text.
Otherwise:

*   ↪ **c:***

    Let `delimiterRunBefore` be `'punctuation'`, let `delimiterRunAfter` be
    `null`, enqueue a t:sequence, consume, and switch to the s:emphasis-asterisk
*   ↪ **c:_**

    Let `delimiterRunBefore` be `'punctuation'`, let `delimiterRunAfter` be
    `null`, enqueue a t:sequence, consume, and switch to the
    s:emphasis-underscore
*   ↪ **Anything else**

    Reconsume in the s:text

### Text state

If text is parsed as plain text, this state should act as per the s:plain-text.
Otherwise:

*   ↪ **[c:EOF][]**

    Enqueue an t:end-of-file
*   ↪ **[c:EOL][]**

    If the break represented by the character starts with a t:whitespace that
    consists of two or more of [c:VS][], [c:HT][], or [c:SP][], enqueue a
    l:text-hard-break, enqueue an t:end-of-line, consume, and switch to the
    s:after-whitespace

    Otherwise, enqueue a l:text-soft-break, enqueue an t:end-of-line, consume,
    and switch to the s:after-whitespace
*   ↪ **c:!**

    Enqueue a l:text-image-label-open, enqueue a t:marker, consume, and switch
    to the s:image-label-exclamation-mark-after
*   ↪ **c:&**

    Enqueue a t:marker, consume, and switch to the s:character-reference
*   ↪ **c:***

    Let `delimiterRunBefore` be `null`, let `delimiterRunAfter` be `null`,
    enqueue a t:sequence, consume, and switch to the s:emphasis-asterisk
*   ↪ **c:<**

    Enqueue a t:content, consume, and switch to the
    s:html-or-autolink-less-than-after
*   ↪ **c:[**

    Enqueue a t:marker, consume, enqueue a l:text-link-open
*   ↪ **U+005C BACKSLASH (`\`)**

    Enqueue a t:marker, consume, and switch to the s:escape-backslash-after
*   ↪ **c:]**

    Enqueue a t:marker, consume, and switch to the
    s:resource-text-or-label-after
*   ↪ **c:_**

    Let `delimiterRunBefore` be `null`, let `delimiterRunAfter` be `null`,
    enqueue a t:sequence, consume, and switch to the s:emphasis-underscore
*   ↪ **c:`**

    Let `sizeOpen` be `1`, enqueue a t:sequence, consume, and switch to the
    s:code-span-open
*   ↪ **[Unicode punctuation][]**

    Consume and switch to the s:after-punctuation
*   ↪ **[Unicode whitespace][]**

    Consume and switch to the s:after-whitespace
*   ↪ **Anything else**

    > ❗️ Todo: handle

### Plain text state

*   ↪ **[c:EOF][]**

    Enqueue an t:end-of-file
    Enqueue a l:content-phrasing
*   ↪ **[c:EOL][]**

    Enqueue a l:text-soft-break, enqueue an t:end-of-line, and consume
*   ↪ **c:&**

    Enqueue a t:marker, consume, and switch to the s:character-reference
*   ↪ **U+005C BACKSLASH (`\`)**

    Enqueue a t:marker, consume, and switch to the s:escape-backslash-after
*   ↪ **Anything else**

    > ❗️ Todo: handle

### Emphasis asterisk state

*   ↪ **[c:EOF][]**\
    ↪ **[c:EOL][]**\
    ↪ **[Unicode whitespace][]**

    Let `delimiterRunAfter` be `'whitespace'` and treat it as per the “anything
    else” entry below
*   ↪ **c:***

    Consume
*   ↪ **[Unicode punctuation][]**

    Let `delimiterRunAfter` be `'punctuation'` and treat it as per the “anything
    else” entry below
*   ↪ **Anything else**

    Let `leftFlanking` be whether both `delimiterRunAfter` is not
    `'whitespace'`, and that either `delimiterRunAfter` is not `'punctuation'`
    or that `delimiterRunBefore` is not `null`

    Let `rightFlanking` be whether both `delimiterRunBefore` is not
    `'whitespace'`, and that either `delimiterRunBefore` is not `'punctuation'`
    or that `delimiterRunAfter` is not `null`

    Unset `delimiterRunBefore`, unset `delimiterRunAfter`, enqueue a
    l:text-emphasis, and reconsume in the s:after-punctuation

### Character reference state

*   ↪ **c:#**

    Enqueue a t:marker, consume, and switch to the s:character-reference-numeric
*   ↪ **[ASCII alphanumeric][]**

    Let `entityName` be the empty string, append the character to `entityName`,
    enqueue a t:content, consume, and switch to the s:character-reference-named
*   ↪ **Anything else**

    > ❗️ Todo: retreat if extensions are supported

    Reconsume in the s:after-punctuation

### Character reference named state

*   ↪ **c:;**

    If `entityName` is a [character reference name][], unset `entityName`,
    enqueue a t:marker, consume, enqueue a l:text-character-reference, and
    switch to the s:after-punctuation

    Otherwise, treat it as per the “anything else” entry below
*   ↪ **[ASCII alphanumeric][]**

    Append the character to `entityName` and consume
*   ↪ **Anything else**

    > ❗️ Todo: retreat if extensions are supported

    Unset `entityName` and reconsume in the s:text

### Character reference numeric state

*   ↪ **c:X**\
    ↪ **c:x**

    Let `characterReferenceCode` be `0`, enqueue a t:marker, consume, and switch
    to the s:character-reference-hexadecimal-start
*   ↪ **[ASCII digit][]**

    Let `characterReferenceCode` be `0`, enqueue a t:content and reconsume in
    the s:character-reference-decimal
*   ↪ **Anything else**

    > ❗️ Todo: retreat if extensions are supported

    Reconsume in the s:after-punctuation

### Character reference hexadecimal start state

*   ↪ **[ASCII hex digit][]**

    Enqueue a t:content and reconsume in the s:character-reference-hexadecimal
*   ↪ **Anything else**

    > ❗️ Todo: retreat if extensions are supported

    Unset `characterReferenceCode` and reconsume in the s:text

### Character reference hexadecimal state

*   ↪ **c:;**

    Unset `characterReferenceCode`, enqueue a t:marker, consume, enqueue a
    l:text-character-reference, and switch to the s:after-punctuation
*   ↪ **[ASCII digit][]**

    Multiply `characterReferenceCode` by `0x10`, add the [digitize][]d
    [input character][] to `characterReferenceCode`, and consume
*   ↪ **[ASCII upper hex digit][]**

    Multiply `characterReferenceCode` by `0x10`, add the [digitize][]d
    [input character][] to `characterReferenceCode`, and consume
*   ↪ **[ASCII lower hex digit][]**

    Multiply `characterReferenceCode` by `0x10`, add the [digitize][]d
    [input character][] to `characterReferenceCode`, and consume
*   ↪ **Anything else**

    > ❗️ Todo: retreat if extensions are supported

    Unset `characterReferenceCode` and reconsume in the s:text

### Character reference decimal state

*   ↪ **c:;**

    Unset `characterReferenceCode`, enqueue a t:marker, consume, enqueue a
    l:text-character-reference, and switch to the s:text
*   ↪ **[ASCII digit][]**

    Multiply `characterReferenceCode` by `10`, add the [digitize][]d
    [input character][] to `characterReferenceCode`, and consume
*   ↪ **Anything else**

    > ❗️ Todo: retreat if extensions are supported

    Unset `characterReferenceCode` and reconsume in the s:text

### Code span open state

*   ↪ **[c:EOF][]**

    Unset `sizeOpen` and reconsume in the s:text
*   ↪ **[c:EOL][]**

    Enqueue a l:text-soft-break, enqueue an t:end-of-line, consume, and switch
    to the s:code-span-inside-start-after
*   ↪ **c:`**

    Increment `sizeOpen` by `1` and consume
*   ↪ **Anything else**

    Enqueue a t:content, consume, and switch to the s:code-span-inside

### Code span inside start after state

> **Note**: EOL is not possible.

*   ↪ **[c:EOF][]**

    > ❗️ Todo: retreat (there may be other constructs we didn’t check for)

    Unset `sizeOpen` and reconsume in the s:text
*   ↪ **c:`**

    Enqueue a t:sequence, let `sizeClose` be `1`, consume, and switch to the
    s:code-span-close
*   ↪ **Anything else**

    Enqueue a t:content, consume, and switch to the s:code-span-inside

### Code span inside state

*   ↪ **[c:EOF][]**

    > ❗️ Todo: retreat (there may be other constructs we didn’t check for)

    Unset `sizeOpen` and reconsume in the s:text
*   ↪ **[c:EOL][]**

    Enqueue a l:text-soft-break, enqueue an t:end-of-line, consume, and switch
    to the s:code-span-inside-start-after
*   ↪ **c:`**

    Enqueue a t:sequence, let `sizeClose` be `1`, consume, and switch to the
    s:code-span-close
*   ↪ **Anything else**

    Consume

### Code span close state

*   ↪ **[c:EOF][]**

    If `sizeOpen` is `sizeClose`, unset `sizeOpen`, unset `sizeClose`, enqueue a
    l:text-code, and reconsume in the s:after-punctuation

    > ❗️ Todo: retreat (there may be other constructs we didn’t check for)

    Otherwise, unset `sizeOpen`, unset `sizeClose`, and reconsume in the
    s:text
*   ↪ **[c:EOL][]**

    If `sizeOpen` is `sizeClose`, unset `sizeOpen`, unset `sizeClose`, enqueue a
    l:text-code, and reconsume in the s:after-punctuation

    Otherwise, unset `sizeClose`, enqueue a l:text-soft-break, enqueue an
    t:end-of-line, consume, and switch to the s:code-span-inside-start-after
*   ↪ **c:`**

    Increment `sizeClose` by `1` and consume
*   ↪ **Anything else**

    If `sizeOpen` is `sizeClose`, unset `sizeOpen`, unset `sizeClose`, enqueue a
    l:text-code, and reconsume in the s:after-punctuation

    Otherwise, unset `sizeClose`, consume, and switch to the s:code-span-inside

### Emphasis underscore state

*   ↪ **[c:EOF][]**\
    ↪ **[c:EOL][]**\
    ↪ **[Unicode whitespace][]**

    Let `delimiterRunAfter` be `'whitespace'` and treat it as per the “anything
    else” entry below
*   ↪ **c:_**

    Consume
*   ↪ **[Unicode punctuation][]**

    Let `delimiterRunAfter` be `'punctuation'` and treat it as per the “anything
    else” entry below
*   ↪ **Anything else**

    Let `leftFlanking` be whether both `delimiterRunAfter` is not
    `'whitespace'`, and that either `delimiterRunAfter` is not `'punctuation'`
    or that `delimiterRunBefore` is not `null`

    Let `rightFlanking` be whether both `delimiterRunBefore` is not
    `'whitespace'`, and that either `delimiterRunBefore` is not `'punctuation'`
    or that `delimiterRunAfter` is not `null`

    Unset `delimiterRunBefore`, unset `delimiterRunAfter`, enqueue a
    l:text-emphasis, and reconsume in the s:after-punctuation

### Escape backslash after state

*   ↪ **[c:EOL][]**

    If text is parsed as rich text, and the break represented by the character
    does not start with a t:whitespace, enqueue a l:text-hard-break, enqueue an
    t:end-of-line, consume, and switch to the s:after-whitespace

    Otherwise, treat it as per the “anything else” entry below
*   ↪ **[ASCII punctuation][]**

    Enqueue a t:content, consume, enqueue a l:text-escape, and switch to the
    s:text
*   ↪ **Anything else**

    Reconsume in the s:after-punctuation

### HTML or autolink less than after state

*   ↪ **c:!**

    Consume and switch to the s:html-declaration-or-email-atext
*   ↪ **c:/**

    Consume and switch to the s:html-tag-close-or-email-atext
*   ↪ **c:?**

    Consume and switch to the s:html-instruction-or-email-atext
*   ↪ **[ASCII alpha][]**

    Consume, let `sizeScheme` be `1`, and switch to the
    s:html-tag-open-scheme-or-email-atext
*   ↪ **[atext][]**\
    ↪ **c:.**

    Consume and switch to the s:autolink-email-atext
*   ↪ **Anything else**

    > ❗️ Todo: retreat if extensions are supported

    Reconsume in the s:after-punctuation

### HTML instruction or email atext state

*   ↪ **[c:EOF][]**\
    ↪ **[c:EOL][]**

    > ❗️ Todo: retreat (there may be other constructs we didn’t check for, and
    > we don’t know if there was punctuation or whitespace)

    Reconsume in the s:text
*   ↪ **c:?**

    Consume and switch to the s:html-instruction-close-or-email-atext
*   ↪ **c:@**

    Consume, let `sizeLabel` be `1`, and switch to the
    s:html-instruction-or-email-at-sign-or-dot
*   ↪ **[atext][]**\
    ↪ **c:.**

    Consume
*   ↪ **Anything else**

    Consume and switch to the s:html-instruction

### HTML instruction close or email atext state

*   ↪ **[c:EOF][]**\
    ↪ **[c:EOL][]**

    > ❗️ Todo: retreat (there may be other constructs we didn’t check for, and
    > we don’t know if there was punctuation or whitespace)

    Reconsume in the s:text
*   ↪ **c:>**

    Consume, enqueue a l:text-html, and switch to the s:after-punctuation
*   ↪ **c:?**

    Consume
*   ↪ **c:@**

    Consume, let `sizeLabel` be `1`, and switch to the
    s:html-instruction-or-email-at-sign-or-dot
*   ↪ **[atext][]**\
    ↪ **c:.**

    Consume and switch to the s:html-instruction-or-email-atext
*   ↪ **Anything else**

    Consume and switch to the s:html-instruction

### HTML instruction or email at sign or dot state

*   ↪ **[c:EOF][]**\
    ↪ **[c:EOL][]**

    > ❗️ Todo: retreat (there may be other constructs we didn’t check for, and
    > we don’t know if there was punctuation or whitespace)

    Reconsume in the s:text
*   ↪ **c:?**

    Unset `sizeLabel`, consume, and switch to the s:html-instruction-close
*   ↪ **[ASCII alphanumeric][]**

    If `sizeLabel` is not `63`, increment `sizeLabel` by `1`, consume, and
    switch to the s:html-instruction-or-email-label

    Otherwise, treat it as per the “anything else” entry below
*   ↪ **Anything else**

    Unset `sizeLabel`, consume, and switch to the s:html-instruction

### HTML instruction or email label state

*   ↪ **[c:EOF][]**\
    ↪ **[c:EOL][]**

    > ❗️ Todo: retreat (there may be other constructs we didn’t check for, and
    > we don’t know if there was punctuation or whitespace)

    Unset `sizeLabel` and reconsume in the s:text
*   ↪ **c:-**

    If `sizeLabel` is not `63`, increment `sizeLabel` by `1`, consume, and
    switch to the s:html-instruction-or-email-dash

    Otherwise, treat it as per the “anything else” entry below
*   ↪ **c:.**

    If `sizeLabel` is not `63`, increment `sizeLabel` by `1`, consume, and
    switch to the s:html-instruction-or-email-at-sign-or-dot

    Otherwise, treat it as per the “anything else” entry below
*   ↪ **c:>**

    Unset `sizeLabel`, consume, enqueue a l:text-autolink-email, and switch to
    the s:after-punctuation
*   ↪ **c:?**

    Unset `sizeLabel`, consume, and switch to the s:html-instruction-close
*   ↪ **[ASCII alphanumeric][]**

    If `sizeLabel` is not `63`, increment `sizeLabel` by `1`, consume, and
    switch to the s:html-instruction-or-email-label

    Otherwise, treat it as per the “anything else” entry below
*   ↪ **Anything else**

    Unset `sizeLabel`, consume, and switch to the s:html-instruction

### HTML instruction or email dash state

*   ↪ **[c:EOF][]**\
    ↪ **[c:EOL][]**

    > ❗️ Todo: retreat (there may be other constructs we didn’t check for, and
    > we don’t know if there was punctuation or whitespace)

    Unset `sizeLabel` and reconsume in the s:text
*   ↪ **c:-**

    If `sizeLabel` is not `63`, increment `sizeLabel` by `1`, consume, and
    switch to the s:html-instruction-or-email-dash

    Otherwise, treat it as per the “anything else” entry below
*   ↪ **c:?**

    Unset `sizeLabel`, consume, and switch to the s:html-instruction-close
*   ↪ **[ASCII alphanumeric][]**

    If `sizeLabel` is not `63`, increment `sizeLabel` by `1`, consume, and
    switch to the s:html-instruction-or-email-label

    Otherwise, treat it as per the “anything else” entry below
*   ↪ **Anything else**

    Unset `sizeLabel`, consume, and switch to the s:html-instruction

### HTML instruction state

*   ↪ **[c:EOF][]**

    > ❗️ Todo: retreat (there may be other constructs we didn’t check for, and
    > we don’t know if there was punctuation or whitespace)

    Reconsume in the s:text
*   ↪ **[c:EOL][]**

    Enqueue a l:text-soft-break, enqueue an t:end-of-line, consume, and enqueue
    a t:content
*   ↪ **c:?**

    Consume and switch to the s:html-instruction-close
*   ↪ **Anything else**

    Consume

### HTML instruction close state

*   ↪ **[c:EOF][]**

    > ❗️ Todo: retreat (there may be other constructs we didn’t check for, and
    > we don’t know if there was punctuation or whitespace)

    Reconsume in the s:text
*   ↪ **[c:EOL][]**

    Enqueue a l:text-soft-break, enqueue an t:end-of-line, consume, enqueue a
    t:content, and switch to the s:html-instruction
*   ↪ **c:>**

    Consume, enqueue a l:text-html, and switch to the s:after-punctuation
*   ↪ **Anything else**

    Consume

### HTML declaration or email atext state

*   ↪ **c:-**

    Consume and switch to the s:html-comment-open-inside-or-email-atext
*   ↪ **c:@**

    Consume, let `sizeLabel` be `1`, and switch to the
    s:autolink-email-at-sign-or-dot
*   ↪ **`[CDATA[` (the five upper letters “CDATA” with a c:[ before and
    after)**

    Consume and switch to the s:html-cdata
*   ↪ **[ASCII upper alpha][]**

    Consume and switch to the s:html-declaration-name-or-email-atext
*   ↪ **[atext][]**\
    ↪ **c:.**

    Consume and switch to the s:autolink-email-atext
*   ↪ **Anything else**

    > ❗️ Todo: figure out if we are after punctuation, whitespace, or something
    > else?

    Reconsume in the s:text

### HTML comment open inside or email atext state

*   ↪ **c:-**

    Consume and switch to the s:html-comment-or-email-atext
*   ↪ **c:@**

    Consume, let `sizeLabel` be `1`, and switch to the
    s:autolink-email-at-sign-or-dot
*   ↪ **[atext][]**\
    ↪ **c:.**

    Consume and switch to the s:autolink-email-atext
*   ↪ **Anything else**

    Reconsume in the s:after-punctuation

### HTML comment or email atext state

*   ↪ **[c:EOF][]**

    > ❗️ Todo: retreat (there may be other constructs we didn’t check for, and
    > we don’t know if there was punctuation or whitespace)

    Reconsume in the s:text
*   ↪ **c:-**

    Consume and switch to the s:html-comment-close-inside-or-email-atext
*   ↪ **c:@**

    Consume, let `sizeLabel` be `1`, and switch to the
    s:html-comment-or-email-at-sign-or-dot
*   ↪ **[atext][]**\
    ↪ **c:.**

    Consume and switch to the s:html-comment-or-email-atext
*   ↪ **Anything else**

    Reconsume in the s:html-comment

### HTML comment close inside or email atext state

*   ↪ **[c:EOF][]**

    > ❗️ Todo: retreat (there may be other constructs we didn’t check for, and
    > we don’t know if there was punctuation or whitespace)

    Reconsume in the s:text
*   ↪ **c:-**

    Consume and switch to the s:html-comment-close-or-email-atext
*   ↪ **c:@**

    Consume, let `sizeLabel` be `1`, and switch to the
    s:html-comment-or-email-at-sign-or-dot
*   ↪ **[atext][]**\
    ↪ **c:.**

    Consume and switch to the s:html-comment-or-email-atext
*   ↪ **Anything else**

    Reconsume in the s:html-comment

### HTML comment close or email atext state

> **Note**: a comment may not contain two dashes (`--`), and may not end in a
> dash (which would result in `--->`).
> Here we have seen two dashes, so we can either be at the end of a comment, or
> no longer in a comment.

*   ↪ **c:>**

    Consume, enqueue a l:text-html, and switch to the s:after-punctuation
*   ↪ **c:@**

    Consume, let `sizeLabel` be `1`, and switch to the
    s:autolink-email-at-sign-or-dot
*   ↪ **[atext][]**\
    ↪ **c:.**

    Consume and switch to the s:autolink-email-atext
*   ↪ **Anything else**

    > ❗️ Todo: retreat (there may be other constructs we didn’t check for)

    Reconsume in the s:after-punctuation

### HTML comment or email at sign or dot state

*   ↪ **[c:EOF][]**

    > ❗️ Todo: retreat (there may be other constructs we didn’t check for)

    Unset `sizeLabel` and reconsume in the s:text
*   ↪ **c:-**

    Unset `sizeLabel`, consume, and switch to the s:html-comment-close-inside
*   ↪ **[ASCII alphanumeric][]**

    If `sizeLabel` is not `63`, increment `sizeLabel` by `1`, consume, and
    switch to the s:html-comment-or-email-label

    Otherwise, treat it as per the “anything else” entry below
*   ↪ **Anything else**

    Unset `sizeLabel` and reconsume in the s:html-comment

### HTML comment or email label state

*   ↪ **[c:EOF][]**

    > ❗️ Todo: retreat (there may be other constructs we didn’t check for, and
    > we don’t know if there was punctuation or whitespace)

    Unset `sizeLabel` and reconsume in the s:text
*   ↪ **c:-**

    If `sizeLabel` is not `63`, increment `sizeLabel` by `1`, consume, and
    switch to the s:html-comment-close-inside-or-email-label-dash

    Otherwise, treat it as per the “anything else” entry below
*   ↪ **c:.**

    If `sizeLabel` is not `63`, increment `sizeLabel` by `1`, consume, and
    switch to the s:html-comment-or-email-at-sign-or-dot

    Otherwise, treat it as per the “anything else” entry below
*   ↪ **c:>**

    Unset `sizeLabel`, consume, enqueue a l:text-autolink-email, and switch to
    the s:after-punctuation
*   ↪ **[ASCII alphanumeric][]**

    If `sizeLabel` is not `63`, increment `sizeLabel` by `1`, consume, and
    switch to the s:html-comment-or-email-label

    Otherwise, treat it as per the “anything else” entry below
*   ↪ **Anything else**

    Unset `sizeLabel` and reconsume in the s:html-comment

### HTML comment close inside or email label dash state

*   ↪ **[c:EOF][]**\
    ↪ **c:>**

    > ❗️ Todo: retreat (there may be other constructs we didn’t check for)

    Unset `sizeLabel` and reconsume in the s:after-punctuation
*   ↪ **c:-**

    If `sizeLabel` is not `63`, increment `sizeLabel` by `1`, consume, and
    switch to the s:html-comment-close-or-email-label-dash

    Otherwise, treat it as per the “anything else” entry below
*   ↪ **[ASCII alphanumeric][]**

    If `sizeLabel` is not `63`, increment `sizeLabel` by `1`, consume, and
    switch to the s:html-comment-or-email-label

    Otherwise, treat it as per the “anything else” entry below
*   ↪ **Anything else**

    Unset `sizeLabel` and reconsume in the s:html-comment

### HTML comment close or email label dash state

> **Note**: a comment may not contain two dashes (`--`), and may not end in a
> dash (which would result in `--->`).
> Here we have seen two dashes, so we can either be at the end of a comment, or
> no longer in a comment.

*   ↪ **c:>**

    Unset `sizeLabel`, consume, enqueue a l:text-html, and switch to the
    s:after-punctuation
*   ↪ **[ASCII alphanumeric][]**

    If `sizeLabel` is not `63`, increment `sizeLabel` by `1`, consume, and
    switch to the s:autolink-email-label

    Otherwise, treat it as per the “anything else” entry below
*   ↪ **Anything else**

    > ❗️ Todo: retreat (there may be other constructs we didn’t check for)

    Unset `sizeLabel` and reconsume in the s:after-punctuation

### HTML comment state

*   ↪ **[c:EOF][]**

    > ❗️ Todo: retreat (there may be other constructs we didn’t check for, and
    > we don’t know if there was punctuation or whitespace)

    Reconsume in the s:text
*   ↪ **[c:EOL][]**

    Enqueue a l:text-soft-break, enqueue an t:end-of-line, consume, and enqueue
    a t:content
*   ↪ **c:-**

    Consume and switch to the s:html-comment-close-inside
*   ↪ **Anything else**

    Consume

### HTML comment close inside state

*   ↪ **[c:EOF][]**

    > ❗️ Todo: retreat (there may be other constructs we didn’t check for)

    Reconsume in the s:after-punctuation
*   ↪ **[c:EOL][]**

    Enqueue a l:text-soft-break, enqueue an t:end-of-line, consume, enqueue a
    t:content, and switch to the s:html-comment
*   ↪ **c:-**

    Consume and switch to the s:html-comment-close
*   ↪ **Anything else**

    Consume

### HTML comment close state

> **Note**: a comment may not contain two dashes (`--`), and may not end in a
> dash (which would result in `--->`).
> Here we have seen two dashes, so we can either be at the end of a comment, or
> no longer in a comment.

*   ↪ **c:>**

    Consume, enqueue a l:text-html, and switch to the s:after-punctuation
*   ↪ **Anything else**

    > ❗️ Todo: retreat (there may be other constructs we didn’t check for)

    Reconsume in the s:after-punctuation

### HTML CDATA state

*   ↪ **[c:EOF][]**

    > ❗️ Todo: retreat (there may be other constructs we didn’t check for)

    Reconsume in the s:text
*   ↪ **[c:EOL][]**

    Enqueue a l:text-soft-break, enqueue an t:end-of-line, consume, and enqueue
    a t:content
*   ↪ **`]]>` (two of c:], with a c:> after)**

    Consume, enqueue a l:text-html, and switch to the s:after-punctuation
*   ↪ **Anything else**

    Consume

### HTML declaration name or email atext state

*   ↪ **[c:EOL][]**\
    ↪ **c:HT**\
    ↪ **c:SP**

    Reconsume in the s:html-declaration-between
*   ↪ **c:@**

    Consume, let `sizeLabel` be `1`, and switch to the
    s:autolink-email-at-sign-or-dot
*   ↪ **[ASCII upper alpha][]**

    Consume
*   ↪ **[atext][]**\
    ↪ **c:.**

    Consume and switch to the s:autolink-email-atext
*   ↪ **Anything else**

    > ❗️ Todo: retreat if extensions are supported

    Reconsume in the s:text

### HTML declaration between state

*   ↪ **[c:EOL][]**

    Enqueue a l:text-soft-break, enqueue an t:end-of-line, consume, and enqueue
    a t:content
*   ↪ **c:HT**\
    ↪ **c:SP**

    Consume
*   ↪ **c:>**

    Consume, enqueue a l:text-html, and switch to the s:after-punctuation
*   ↪ **Anything else**

    Reconsume in the s:html-declaration-content

### HTML declaration content state

*   ↪ **[c:EOF][]**

    > ❗️ Todo: retreat (there may be other constructs we didn’t check for, and
    > we don’t know if there was punctuation or whitespace)

    Reconsume in the s:text
*   ↪ **[c:EOL][]**

    Enqueue a l:text-soft-break, enqueue an t:end-of-line, consume, and enqueue
    a t:content
*   ↪ **c:>**

    Consume, enqueue a l:text-html, and switch to the s:after-punctuation
*   ↪ **Anything else**

    Consume

### HTML tag close or email atext state

*   ↪ **c:@**

    Consume, let `sizeLabel` be `1`, and switch to the
    s:autolink-email-at-sign-or-dot
*   ↪ **[ASCII alpha][]**

    Consume and switch to the s:html-tag-close-inside-or-email-atext
*   ↪ **[atext][]**\
    ↪ **c:.**

    Consume and switch to the s:autolink-email-atext
*   ↪ **Anything else**

    > ❗️ Todo: retreat if extensions are supported

    Reconsume in the s:after-punctuation

### HTML tag close inside or email atext state

*   ↪ **[c:EOL][]**\
    ↪ **c:HT**\
    ↪ **c:SP**

    Reconsume in the s:html-tag-close-between
*   ↪ **c:>**

    Consume, enqueue a l:text-html, and switch to the s:after-punctuation
*   ↪ **c:@**

    Consume, let `sizeLabel` be `1`, and switch to the
    s:autolink-email-at-sign-or-dot
*   ↪ **[ASCII alphanumeric][]**\
    ↪ **c:-**

    Consume
*   ↪ **[atext][]**\
    ↪ **c:.**

    Consume and switch to the s:autolink-email-atext
*   ↪ **Anything else**

    > ❗️ Todo: retreat if extensions are supported

    Reconsume in the s:text

### HTML tag close between state

> **Note**: an EOL would technically be allowed here, but anything else isn’t,
> and as a `>` after an EOL would start a blockquote, practically it’s not
> possible.

*   ↪ **c:>**

    Consume, enqueue a l:text-html, and switch to the s:after-punctuation
*   ↪ **Anything else**

    > ❗️ Todo: retreat if extensions are supported

    Reconsume in the s:after-whitespace

### HTML tag open scheme or email atext state

*   ↪ **c:+**\
    ↪ **c:.**

    Increment `sizeScheme` by `1`, consume, and switch to the
    s:autolink-scheme-inside-or-email-atext
*   ↪ **c:>**

    Unset `sizeScheme`, consume, enqueue a l:text-html, and switch to the
    s:after-punctuation
*   ↪ **[ASCII alphanumeric][]**\
    ↪ **c:-**

    Increment `sizeScheme` by `1`, consume, and switch to the
    s:html-tag-open-inside-scheme-inside-or-email-atext
*   ↪ **[atext][]**

    Unset `sizeScheme`, consume, and switch to the s:autolink-email-atext
*   ↪ **Anything else**

    > ❗️ Todo: retreat (we don’t know if there was punctuation (dash) or not)

    Unset `sizeScheme` and reconsume in the s:text

### HTML tag open inside scheme inside or email atext state

*   ↪ **[c:EOL][]**

    Unset `sizeScheme`, enqueue a l:text-soft-break, enqueue an t:end-of-line,
    consume, enqueue a t:content, and switch to the
    s:html-tag-open-between-start-after
*   ↪ **c:HT**\
    ↪ **c:SP**

    Unset `sizeScheme`, consume, and switch to the s:html-tag-open-between
*   ↪ **c:+**\
    ↪ **c:.**

    If `sizeScheme` is not `32`, increment `sizeScheme` by `1`, consume, and
    switch to the s:autolink-scheme-inside-or-email-atext

    Otherwise, treat it as per the “atext” entry below
*   ↪ **c::**

    Unset `sizeScheme`, consume, and switch to the s:autolink-uri-inside
*   ↪ **c:@**

    Unset `sizeScheme`, consume, let `sizeLabel` be `1`, and switch to the
    s:autolink-email-at-sign-or-dot
*   ↪ **[ASCII alphanumeric][]**\
    ↪ **c:-**

    If `sizeScheme` is not `32`, increment `sizeScheme` by `1` and consume

    Otherwise, unset `sizeScheme`, consume, and switch to the
    s:html-tag-open-inside-or-email-atext
*   ↪ **[atext][]**

    Unset `sizeScheme`, consume, and switch to the s:autolink-email-atext
*   ↪ **Anything else**

    > ❗️ Todo: retreat (we don’t know if there was punctuation (dash) or not)

    Unset `sizeScheme` and reconsume in the s:text

### HTML tag open inside or email atext state

*   ↪ **[c:EOL][]**

    Enqueue a l:text-soft-break, enqueue an t:end-of-line, consume, enqueue a
    t:content, and switch to the s:html-tag-open-between-start-after
*   ↪ **c:HT**\
    ↪ **c:SP**

    Consume and switch to the s:html-tag-open-between
*   ↪ **c:@**

    Consume, let `sizeLabel` be `1`, and switch to the
    s:autolink-email-at-sign-or-dot
*   ↪ **[ASCII alphanumeric][]**\
    ↪ **c:-**

    Consume
*   ↪ **[atext][]**\
    ↪ **c:.**

    Consume and switch to the s:autolink-email-atext
*   ↪ **Anything else**

    > ❗️ Todo: retreat (we don’t know if there was punctuation (dash) or not)

    Reconsume in the s:text

### HTML tag open between start after state

> **Note**: EOL is not possible.

*   ↪ **c:HT**\
    ↪ **c:SP**

    Consume and switch to the s:html-tag-open-between
*   ↪ **Anything else**

    Reconsume in the s:html-tag-open-between

### HTML tag open between state

*   ↪ **[c:EOL][]**

    Enqueue a l:text-soft-break, enqueue an t:end-of-line, consume, enqueue a
    t:content, and switch to the s:html-tag-open-between-start-after
*   ↪ **c:HT**\
    ↪ **c:SP**

    Consume
*   ↪ **c:/**

    Consume and switch to the s:html-tag-open-self-closing
*   ↪ **c:>**

    Consume, enqueue a l:text-html, and switch to the s:after-punctuation
*   ↪ **[ASCII alpha][]**\
    ↪ **c::**\
    ↪ **c:_**

    Consume and switch to the s:html-tag-open-attribute-name
*   ↪ **Anything else**

    > ❗️ Todo: retreat if extensions are supported

    Reconsume in the s:after-whitespace

### HTML tag open attribute name state

*   ↪ **[ASCII alphanumeric][]**\
    ↪ **c:-**\
    ↪ **c:.**\
    ↪ **c::**\
    ↪ **c:_**

    Consume
*   ↪ **Anything else**

    Reconsume in the s:html-tag-open-attribute-name-after

### HTML tag open attribute name after state

*   ↪ **[c:EOL][]**

    Enqueue a l:text-soft-break, enqueue an t:end-of-line, consume, and enqueue
    a t:content
*   ↪ **c:HT**\
    ↪ **c:SP**

    Consume
*   ↪ **c:/**

    Consume and switch to the s:html-tag-open-self-closing
*   ↪ **c:=**

    Consume and switch to the s:html-tag-open-attribute-value-before
*   ↪ **c:>**

    Consume, enqueue a l:text-html, and switch to the s:after-punctuation
*   ↪ **Anything else**

    > ❗️ Todo: retreat (we don’t know if there was punctuation or whitespace)

    Reconsume in the s:text

### HTML tag open attribute value before state

*   ↪ **[c:EOL][]**

    Enqueue a l:text-soft-break, enqueue an t:end-of-line, consume, and enqueue
    a t:content
*   ↪ **c:HT**\
    ↪ **c:SP**

    Consume
*   ↪ **c:"**

    Consume and switch to the s:html-tag-open-double-quoted-attribute-value
*   ↪ **c:'**

    Consume and switch to the s:html-tag-open-single-quoted-attribute-value
*   ↪ **c:<**\
    ↪ **c:=**\
    ↪ **c:>**\
    ↪ **c:`**

    > ❗️ Todo: retreat (we don’t know if there was punctuation or whitespace)

    Reconsume in the s:text
*   ↪ **Anything else**

    Consume and switch to the s:html-tag-open-unquoted-attribute-value

### HTML tag open double quoted attribute value state

*   ↪ **[c:EOF][]**

    > ❗️ Todo: retreat (there may be other constructs we didn’t check for)

    Reconsume in the s:text
*   ↪ **[c:EOL][]**

    Enqueue a l:text-soft-break, enqueue an t:end-of-line, consume, and enqueue
    a t:content
*   ↪ **c:"**

    Consume and switch to the s:html-tag-open-between
*   ↪ **Anything else**

    Consume

### HTML tag open single quoted attribute value state

*   ↪ **[c:EOF][]**

    > ❗️ Todo: retreat (there may be other constructs we didn’t check for)

    Reconsume in the s:text
*   ↪ **[c:EOL][]**

    Enqueue a l:text-soft-break, enqueue an t:end-of-line, consume, and enqueue
    a t:content
*   ↪ **c:'**

    Consume and switch to the s:html-tag-open-between
*   ↪ **Anything else**

    Consume

### HTML tag open unquoted attribute value state

*   ↪ **[c:EOF][]**\
    ↪ **c:"**\
    ↪ **c:'**\
    ↪ **c:<**\
    ↪ **c:=**\
    ↪ **c:`**

    > ❗️ Todo: retreat (there may be other constructs we didn’t check for)

    Reconsume in the s:text
*   ↪ **[c:EOL][]**

    Enqueue a l:text-soft-break, enqueue an t:end-of-line, consume, enqueue a
    t:content, and switch to the s:html-tag-open-between
*   ↪ **c:HT**\
    ↪ **c:SP**\

    Consume and switch to the s:html-tag-open-between
*   ↪ **c:>**

    Consume, enqueue a l:text-html, and switch to the s:after-punctuation
*   ↪ **Anything else**

    Consume

### HTML tag open self closing state

*   ↪ **c:>**

    Consume, enqueue a l:text-html, and switch to the s:after-punctuation
*   ↪ **Anything else**

    > ❗️ Todo: retreat (there may be other constructs we didn’t check for)

    Reconsume in the s:after-punctuation

### Autolink scheme inside or email atext state

*   ↪ **c::**

    Unset `sizeScheme`, consume, and switch to the s:autolink-uri-inside
*   ↪ **c:@**

    Unset `sizeScheme`, consume, let `sizeLabel` be `1`, and switch to the
    s:autolink-email-at-sign-or-dot
*   ↪ **[ASCII alphanumeric][]**\
    ↪ **c:+**\
    ↪ **c:-**\
    ↪ **c:.**

    If `sizeScheme` is not `32`, increment `sizeScheme` by `1` and consume

    Otherwise, treat it as per the “atext” entry below
*   ↪ **[atext][]**

    Unset `sizeScheme`, consume, and switch to the s:autolink-email-atext
*   ↪ **Anything else**

    > ❗️ Todo: retreat (we don’t know if there was punctuation or not)

    Unset `sizeScheme` and reconsume in the s:text

### Autolink URI inside state

*   ↪ **[c:EOF][]**\
    ↪ **[c:EOL][]**\
    ↪ **[ASCII control][]**\
    ↪ **c:SP**\
    ↪ **c:<**

    > ❗️ Todo: retreat (we don’t know if there was punctuation or whitespace)

    Reconsume in the s:text
*   ↪ **c:>**

    Consume, enqueue a l:text-autolink-uri, and switch to the
    s:after-punctuation
*   ↪ **Anything else**

    Consume

### Autolink email atext state

*   ↪ **c:@**

    Consume, let `sizeLabel` be `1`, and switch to the
    s:autolink-email-at-sign-or-dot
*   ↪ **[atext][]**\
    ↪ **c:.**

    Consume
*   ↪ **Anything else**

    > ❗️ Todo: retreat (we don’t know if there was punctuation or whitespace)

    Reconsume in the s:text

### Autolink email label state

*   ↪ **c:-**

    If `sizeLabel` is not `63`, increment `sizeLabel` by `1`, consume, and
    switch to the s:autolink-email-dash

    Otherwise, treat it as per the “anything else” entry below
*   ↪ **c:.**

    If `sizeLabel` is not `63`, increment `sizeLabel` by `1`, consume, and
    switch to the s:autolink-email-at-sign-or-dot

    Otherwise, treat it as per the “anything else” entry below
*   ↪ **c:>**

    Unset `sizeLabel`, consume, enqueue a l:text-autolink-email, and switch to
    the s:after-punctuation
*   ↪ **[ASCII alphanumeric][]**

    If `sizeLabel` is not `63`, increment `sizeLabel` by `1` and consume

    Otherwise, treat it as per the “anything else” entry below
*   ↪ **Anything else**

    > ❗️ Todo: retreat (we don’t know if there was punctuation)

    Unset `sizeLabel` and reconsume in the s:text

### Autolink email at sign or dot state

*   ↪ **[ASCII alphanumeric][]**

    If `sizeLabel` is not `63`, increment `sizeLabel` by `1`, consume, and
    switch to the s:autolink-email-label

    Otherwise, treat it as per the “anything else” entry below
*   ↪ **Anything else**

    > ❗️ Todo: retreat if extensions are supported

    Unset `sizeLabel` and reconsume in the s:after-punctuation

### Autolink email dash state

*   ↪ **c:-**

    If `sizeLabel` is not `63`, increment `sizeLabel` by `1` and consume

    Otherwise, treat it as per the “anything else” entry below
*   ↪ **[ASCII alphanumeric][]**

    If `sizeLabel` is not `63`, increment `sizeLabel` by `1`, consume, and
    switch to the s:autolink-email-label

    Otherwise, treat it as per the “anything else” entry below
*   ↪ **Anything else**

    > ❗️ Todo: retreat if extensions are supported

    Unset `sizeLabel` and reconsume in the s:after-punctuation

### Image label exclamation mark after state

*   ↪ **c:[**

    Enqueue a t:marker, consume, enqueue a l:text-image-open, and switch to the
    s:after-punctuation
*   ↪ **Anything else**

    > ❗️ Todo: retreat if extensions are supported

    Reconsume in the s:after-punctuation

### Resource text or label after state

*   ↪ **c:(**

    Enqueue a t:marker, consume, enqueue a l:text-resource-information-open, and
    switch to the s:resource-information-open
*   ↪ **c:[**

    Enqueue a t:marker, consume, enqueue a l:text-reference-label-open, and
    switch to the s:reference-label-open-after
*   ↪ **Anything else**

    > ❗️ Todo: shortcut reference

### Resource information open state

*   ↪ **[c:EOF][]**

    > ❗️ Todo: retreat

    Reconsume in the s:after-punctuation
*   ↪ **[c:EOL][]**

    Enqueue a l:text-soft-break, enqueue an t:end-of-line, and consume
*   ↪ **c:HT**\
    ↪ **c:SP**

    Enqueue a t:whitespace, consume, and switch to the
    s:resource-information-open-after
*   ↪ **c:)**

    Enqueue a t:marker, consume, enqueue a l:text-resource-information-close,
    and switch to the s:after-punctuation
*   ↪ **c:<**

    Enqueue a l:text-resource-destination-quoted-open, enqueue a t:marker,
    consume, and switch to the s:resource-destination-quoted-open-after
*   ↪ **[ASCII control][]**

    > ❗️ Todo: retreat

    Reconsume in the s:after-punctuation
*   ↪ **Anything else**

    Let `balance` be `0`, enqueue a l:text-resource-destination-unquoted-open,
    enqueue a t:content and reconsume in the
    s:resource-destination-unquoted-inside

### Resource information open after state

*   ↪ **[c:EOF][]**

    > ❗️ Todo: retreat

    Reconsume in the s:after-whitespace
*   ↪ **[c:EOL][]**

    Enqueue a l:text-soft-break, enqueue an t:end-of-line, consume, enqueue a
    t:content, and switch to the s:resource-information-open
*   ↪ **c:HT**\
    ↪ **c:SP**

    Consume
*   ↪ **c:)**

    Enqueue a t:marker, consume, enqueue a l:text-resource-information-close,
    and switch to the s:after-punctuation
*   ↪ **c:<**

    Enqueue a l:text-resource-destination-quoted-open, enqueue a t:marker,
    consume, and switch to the s:resource-destination-quoted-open-after
*   ↪ **[ASCII control][]**

    > ❗️ Todo: retreat

    Reconsume in the s:after-whitespace
*   ↪ **Anything else**

    Let `balance` be `0`, enqueue a l:text-resource-destination-unquoted-open,
    enqueue a t:content and reconsume in the
    s:resource-destination-unquoted-inside

### Resource destination quoted open after state

*   ↪ **[c:EOF][]**\
    ↪ **[c:EOL][]**\
    ↪ **c:<**

    > ❗️ Todo: retreat

    Reconsume in the s:after-whitespace
*   ↪ **c:>**

    Enqueue a t:marker, consume, enqueue a
    l:text-resource-destination-quoted-close, and switch to the
    s:resource-destination-quoted-close-after
*   ↪ **U+005C BACKSLASH (`\`)**

    Enqueue a t:content, consume, and switch to the
    s:resource-destination-quoted-escape
*   ↪ **Anything else**

    Enqueue a t:content, consume, and switch to the
    s:resource-destination-quoted-inside

### Resource destination quoted inside state

*   ↪ **[c:EOF][]**\
    ↪ **[c:EOL][]**\
    ↪ **c:<**

    > ❗️ Todo: retreat (we don’t know if we’re at punctuation or whitespace)

    Reconsume in the s:text
*   ↪ **c:>**

    Enqueue a t:marker, consume, enqueue a
    l:text-resource-destination-quoted-close, and switch to the
    s:resource-destination-quoted-close-after
*   ↪ **U+005C BACKSLASH (`\`)**

    Consume and switch to the s:resource-destination-quoted-escape
*   ↪ **Anything else**

    Consume

### Resource destination quoted escape state

*   ↪ **c:<**\
    ↪ **c:>**\
    ↪ **U+005C BACKSLASH (`\`)**

    Consume and switch to the s:resource-destination-quoted-inside
*   ↪ **Anything else**

    Reconsume in the s:resource-destination-quoted-inside

### Resource destination quoted close after state

*   ↪ **[c:EOF][]**

    > ❗️ Todo: retreat

    Reconsume in the s:after-punctuation
*   ↪ **[c:EOL][]**

    Enqueue a l:text-soft-break, enqueue an t:end-of-line, consume, enqueue a
    t:content, and switch to the s:resource-information-between
*   ↪ **c:HT**\
    ↪ **c:SP**

    Enqueue a t:whitespace, consume, and switch to the
    s:resource-information-between-after
*   ↪ **c:)**

    Enqueue a t:marker, consume, enqueue a l:text-resource-information-close,
    and switch to the s:after-punctuation
*   ↪ **Anything else**

    > ❗️ Todo: retreat

    Reconsume in the s:after-punctuation

### Resource information between state

*   ↪ **[c:EOL][]**

    Enqueue a l:text-soft-break, enqueue an t:end-of-line, and consume
*   ↪ **c:HT**\
    ↪ **c:SP**

    Enqueue a t:whitespace, consume, and switch to the
    s:resource-information-between-after
*   ↪ **Anything else**

    Reconsume in the s:resource-information-between-after

### Resource information between after state

*   ↪ **[c:EOF][]**

    > ❗️ Todo: retreat

    Reconsume in the s:after-whitespace
*   ↪ **[c:EOL][]**

    Enqueue a l:text-soft-break, enqueue an t:end-of-line, consume, enqueue a
    t:content, and switch to the s:resource-information-between
*   ↪ **c:HT**\
    ↪ **c:SP**

    Consume
*   ↪ **c:"**

    Enqueue a l:text-resource-title-open, enqueue a t:marker, consume, and
    switch to the s:resource-title-double-quoted-open-after
*   ↪ **c:'**

    Enqueue a l:text-resource-title-open, enqueue a t:marker, consume, and
    switch to the s:resource-title-single-quoted-open-after
*   ↪ **c:(**

    Enqueue a l:text-resource-title-open, enqueue a t:marker, consume, and
    switch to the s:resource-title-paren-quoted-open-after
*   ↪ **c:)**

    Enqueue a t:marker, consume, enqueue a l:text-resource-information-close,
    and switch to the s:after-punctuation
*   ↪ **Anything else**

    > ❗️ Todo: retreat

    Reconsume in the s:initial-whitespace

### Resource destination unquoted inside state

*   ↪ **[c:EOF][]**

    > ❗️ Todo: retreat (we don’t know if there was punctuation or whitespace)

    Unset `balance` and reconsume in the s:text
*   ↪ **[c:EOL][]**\
    ↪ **c:HT**\
    ↪ **c:SP**

    Unset `balance`, enqueue a l:text-resource-destination-unquoted-close, and
    reconsume in the s:resource-information-between
*   ↪ **c:(**

    Increment `balance` by `1` and consume
*   ↪ **c:)**

    If `balance` is `0`, unset `balance`, enqueue a
    l:text-resource-destination-unquoted-close, enqueue a t:marker, consume,
    enqueue a l:text-resource-information-close, and switch to the
    s:after-punctuation

    Otherwise, decrement `balance` by `1`, and consume
*   ↪ **U+005C BACKSLASH (`\`)**

    Consume and switch to the s:resource-destination-unquoted-escape
*   ↪ **[ASCII control][]**

    > ❗️ Todo: retreat (we don’t know if there was punctuation or whitespace)

    Unset `balance` and reconsume in the s:text
*   ↪ **Anything else**

    Consume

### Resource destination unquoted escape state

*   ↪ **c:(**\
    ↪ **c:)**\
    ↪ **U+005C BACKSLASH (`\`)**

    Consume and switch to the s:resource-destination-unquoted-inside
*   ↪ **Anything else**

    Reconsume in the s:resource-destination-unquoted-inside

### Resource title double quoted open after state

*   ↪ **[c:EOF][]**

    > ❗️ Todo: retreat (we don’t know if there was punctuation or whitespace)

    Reconsume in the s:text
*   ↪ **[c:EOL][]**

    Enqueue a l:text-soft-break, enqueue an t:end-of-line, and consume
*   ↪ **c:"**

    Enqueue a t:marker, consume, enqueue a l:text-resource-title-close, and
    switch to the s:resource-title-close-after
*   ↪ **U+005C BACKSLASH (`\`)**

    Enqueue a t:content, consume, and switch to the
    s:resource-title-double-quoted-escape
*   ↪ **Anything else**

    Enqueue a t:content, consume, and switch to the
    s:resource-title-double-quoted-inside

### Resource title double quoted inside state

*   ↪ **[c:EOF][]**

    > ❗️ Todo: retreat (we don’t know if there was punctuation or whitespace)

    Reconsume in the s:text
*   ↪ **[c:EOL][]**

    Enqueue a l:text-soft-break, enqueue an t:end-of-line, consume, enqueue a
    t:content, and switch to the s:resource-title-double-quoted-open-after
*   ↪ **c:"**

    Enqueue a t:marker, consume, enqueue a l:text-resource-title-close, and
    switch to the s:resource-title-close-after
*   ↪ **U+005C BACKSLASH (`\`)**

    Consume and switch to the s:resource-title-double-quoted-escape
*   ↪ **Anything else**

    Consume

### Resource title double quoted escape state

*   ↪ **c:"**\
    ↪ **U+005C BACKSLASH (`\`)**

    Consume and switch to the s:resource-title-double-quoted-open-after
*   ↪ **Anything else**

    Reconsume in the s:resource-title-double-quoted-open-after

### Resource title single quoted open after state

*   ↪ **[c:EOF][]**

    > ❗️ Todo: retreat (we don’t know if there was punctuation or whitespace)

    Reconsume in the s:text
*   ↪ **[c:EOL][]**

    Enqueue a l:text-soft-break, enqueue an t:end-of-line, and consume
*   ↪ **c:'**

    Enqueue a t:marker, consume, enqueue a l:text-resource-title-close, and
    switch to the s:resource-title-close-after
*   ↪ **U+005C BACKSLASH (`\`)**

    Enqueue a t:content, consume, and switch to the
    s:resource-title-single-quoted-escape
*   ↪ **Anything else**

    Enqueue a t:content, consume, and switch to the
    s:resource-title-single-quoted-inside

### Resource title single quoted inside state

*   ↪ **[c:EOF][]**

    > ❗️ Todo: retreat (we don’t know if there was punctuation or whitespace)

    Reconsume in the s:text
*   ↪ **[c:EOL][]**

    Enqueue a l:text-soft-break, enqueue an t:end-of-line, consume, enqueue a
    t:content, and switch to the s:resource-title-single-quoted-open-after
*   ↪ **c:'**

    Enqueue a t:marker, consume, enqueue a l:text-resource-title-close, and
    switch to the s:resource-title-close-after
*   ↪ **U+005C BACKSLASH (`\`)**

    Consume and switch to the s:resource-title-single-quoted-escape
*   ↪ **Anything else**

    Consume

### Resource title single quoted escape state

*   ↪ **c:'**\
    ↪ **U+005C BACKSLASH (`\`)**

    Consume and switch to the s:resource-title-single-quoted-open-after
*   ↪ **Anything else**

    Reconsume in the s:resource-title-single-quoted-open-after

### Resource title paren quoted open after state

*   ↪ **[c:EOF][]**

    > ❗️ Todo: retreat (we don’t know if there was punctuation or whitespace)

    Reconsume in the s:text
*   ↪ **[c:EOL][]**

    Enqueue a l:text-soft-break, enqueue an t:end-of-line, and consume
*   ↪ **c:)**

    Enqueue a t:marker, consume, enqueue a l:text-resource-title-close, and
    switch to the s:resource-title-close-after
*   ↪ **U+005C BACKSLASH (`\`)**

    Enqueue a t:content, consume, and switch to the
    s:resource-title-paren-quoted-escape
*   ↪ **Anything else**

    Enqueue a t:content, consume, and switch to the
    s:resource-title-paren-quoted-inside

### Resource title paren quoted inside state

*   ↪ **[c:EOF][]**

    > ❗️ Todo: retreat (we don’t know if there was punctuation or whitespace)

    Reconsume in the s:text
*   ↪ **[c:EOL][]**

    Enqueue a l:text-soft-break, enqueue an t:end-of-line, consume, enqueue a
    t:content, and switch to the s:resource-title-paren-quoted-open-after
*   ↪ **c:)**

    Enqueue a t:marker, consume, enqueue a l:text-resource-title-close, and
    switch to the s:resource-title-close-after
*   ↪ **U+005C BACKSLASH (`\`)**

    Consume and switch to the s:resource-title-paren-quoted-escape
*   ↪ **Anything else**

    Consume

### Resource title paren quoted escape state

*   ↪ **c:)**\
    ↪ **U+005C BACKSLASH (`\`)**

    Consume and switch to the s:resource-title-paren-quoted-open-after
*   ↪ **Anything else**

    Reconsume in the s:resource-title-paren-quoted-open-after

### Resource title close after state

*   ↪ **[c:EOF][]**

    > ❗️ Todo: retreat (we don’t know if there was punctuation or whitespace)

    Reconsume in the s:text
*   ↪ **[c:EOL][]**

    Enqueue a l:text-soft-break, enqueue an t:end-of-line, and consume
*   ↪ **c:HT**\
    ↪ **c:SP**

    Enqueue a t:whitespace, consume, and switch to the
    s:resource-information-close-before
*   ↪ **c:)**

    Enqueue a t:marker, consume, enqueue a l:text-resource-information-close,
    and switch to the s:after-punctuation
*   ↪ **Anything else**

    > ❗️ Todo: retreat (we don’t know if there was punctuation or whitespace)

    Reconsume in the s:text

### Resource information close before state

*   ↪ **[c:EOL][]**

    Reconsume in the s:resource-title-close-after
*   ↪ **c:HT**\
    ↪ **c:SP**

    Consume
*   ↪ **c:)**

    Enqueue a t:marker, consume, enqueue a l:text-resource-information-close,
    and switch to the s:after-punctuation
*   ↪ **Anything else**

    > ❗️ Todo: retreat (we don’t know if there was punctuation or whitespace)

    Reconsume in the s:after-whitespace

### Reference label open after state

*   ↪ **[c:EOF][]**

    > ❗️ Todo: retreat (we don’t know if there was punctuation or whitespace)

    Reconsume in the s:text
*   ↪ **[c:EOL][]**

    Enqueue a l:text-soft-break, enqueue an t:end-of-line, and consume
*   ↪ **c:HT**\
    ↪ **c:SP**

    Enqueue a t:whitespace, consume, and switch to the s:reference-label-before
*   ↪ **c:]**

    Enqueue a t:marker, consume, enqueue a l:text-reference-label-close, and
    switch to the s:after-punctuation
*   ↪ **Anything else**

    Enqueue a t:content, consume, and switch to the s:reference-label-inside

### Reference label before state

> **Note**: EOL is not possible.

*   ↪ **[c:EOF][]**\
    ↪ **[c:EOL][]**\
    ↪ **c:]**

    > ❗️ Todo: retreat (we don’t know if there was punctuation or whitespace)

    Reconsume in the s:text
*   ↪ **c:HT**\
    ↪ **c:SP**

    Consume
*   ↪ **Anything else**

    Enqueue a t:content, consume, and switch to the s:reference-label-inside

### Reference label inside state

*   ↪ **[c:EOF][]**

    > ❗️ Todo: retreat

    Reconsume in the s:text
*   ↪ **[c:EOL][]**

    Enqueue a l:text-soft-break, enqueue an t:end-of-line, consume, enqueue a
    t:content, and switch to the s:reference-label-inside-start-after
*   ↪ **c:HT**\
    ↪ **c:SP**

    Enqueue a t:whitespace, consume, and switch to the s:reference-label-between
*   ↪ **U+005C BACKSLASH (`\`)**

    Consume and switch to the s:reference-label-escape
*   ↪ **c:]**

    Enqueue a t:marker, consume, enqueue a l:text-reference-label-close, and
    switch to the s:after-punctuation
*   ↪ **Anything else**

    Consume

### Reference label inside start after state

> **Note**: EOL is not possible.

*   ↪ **[c:EOF][]**

    > ❗️ Todo: retreat

    Reconsume in the s:after-whitespace
*   ↪ **c:HT**\
    ↪ **c:SP**

    Enqueue a t:whitespace, consume, and switch to the s:reference-label-between
*   ↪ **U+005C BACKSLASH (`\`)**

    Consume and switch to the s:reference-label-escape
*   ↪ **c:]**

    Enqueue a t:marker, consume, enqueue a l:text-reference-label-close, and
    switch to the s:after-punctuation
*   ↪ **Anything else**

    Enqueue a t:content, consume, and switch to the s:reference-label-inside

### Reference label between state

*   ↪ **[c:EOF][]**

    > ❗️ Todo: retreat

    Reconsume in the s:after-whitespace
*   ↪ **[c:EOL][]**

    Enqueue a l:text-soft-break, enqueue an t:end-of-line, consume, enqueue a
    t:content, and switch to the s:reference-label-inside-start-after
*   ↪ **c:HT**\
    ↪ **c:SP**

    Consume
*   ↪ **U+005C BACKSLASH (`\`)**

    Enqueue a t:content, consume, and switch to the s:reference-label-escape
*   ↪ **c:]**

    Enqueue a t:marker, consume, enqueue a l:text-reference-label-close, and
    switch to the s:after-punctuation
*   ↪ **Anything else**

    Enqueue a t:content, consume, and switch to the s:reference-label-inside

### Reference label escape state

*   ↪ **U+005C BACKSLASH (`\`)**\
    ↪ **c:]**

    Consume and switch to the s:reference-label-inside
*   ↪ **Anything else**

    Reconsume in the s:reference-label-inside

## Labels

### NOK label

### Content phrasing label

When a l:content-phrasing is received, the queue up to that point does not
construct a definition.

### Content definition label

When a l:content-definition is received, the queue up to that point constructs a
definition.

### Content definition partial label

When a l:content-definition-partial is received, the queue up to that point
constructs a definition without a title.
It is later followed by a l:content-definition if further queued tokens
construct a title, or l:content-phrasing if further queued tokens do not
construct a title.

### Content definition start label

### Content definition label start label

### Content definition label open label

When a l:content-definition-label-open is received, …

### Content definition label close label

When a l:content-definition-label-close is received, …

### Content definition label end label

### Content definition destination start label

### Content definition destination quoted open label

When a l:content-definition-destination-quoted-open is received, …

### Content definition destination quoted close label

When a l:content-definition-destination-quoted-close is received, …

### Content definition destination unquoted open label

When a l:content-definition-destination-unquoted-open is received, …

### Content definition destination unquoted close label

When a l:content-definition-destination-unquoted-close is received, …

### Content definition destination end label

### Content definition title start label

### Content definition title open label

When a l:content-definition-title-open is received, …

### Content definition title close label

When a l:content-definition-title-close is received, …

### Content definition title end label

### Content definition end label

### Text hard break label

When a l:text-hard-break is received, …

### Text soft break label

When a l:text-hard-break is received, …

### Text link open label

When a l:text-link-open is received, …

### Text image label open label

l:text-image-label-open

### Text image open label

When a l:text-image-open is received, …

### Text resource close label

When a l:text-resource-close is received, …

### Text reference label open label

When a l:text-reference-label-open is received, …

### Text reference label close label

When a l:text-reference-label-close is received, …

### Text resource information open label

When a l:text-resource-information-open is received, …

### Text resource destination quoted open label

When a l:text-resource-destination-quoted-open is received, …

### Text resource destination quoted close label

When a l:text-resource-destination-quoted-close is received, …

### Text resource destination unquoted open label

When a l:text-resource-destination-unquoted-open is received, …

### Text resource destination unquoted close label

When a l:text-resource-destination-unquoted-close is received, …

### Text resource title open label

When a l:text-resource-title-open is received, …

### Text resource title close label

When a l:text-resource-title-close is received, …

### Text resource information close label

When a l:text-resource-information-close is received, …

### Text emphasis label

When a l:text-emphasis is received, …

### Text character reference label

When a l:text-character-reference is received, …

### Text escape label

When a l:text-escape is received, …

### Text code label

When a l:text-code is received, …

### Text autolink email label

When a l:text-autolink-email is received, …

### Text autolink URI label

When a l:text-autolink-uri is received, …

### Text HTML label

When a l:text-html is received, …

## Processing

### Process as an ATX heading

To [process as an ATX heading](#) is to perform the following steps:

*   Let `index` be the number of tokens in the queue
*   If the token in the queue before `index` is a t:whitespace, subtract `1`
    from `index`
*   If the token in the queue before `index` is a t:sequence, subtract `1` from
    `index`
*   If the token in the queue before `index` is a t:whitespace, subtract `1`
    from `index`
*   If `index` is not `0`:

    *   Let `last` be the token at `index` if there is one, or otherwise the
        last token in the queue
    *   Let `line` be a line without an ending where `start` is the start
        position of the token at `0`, and `end` is the end position of `last`
    *   Open an g:atx-heading-content
    *   [Process as Phrasing][] with `lines` set to a list with a single entry
        `line`
    *   Close
*   If there is a token at `index` in queue:

    *   Open an g:atx-heading-fence
    *   Emit the tokens in the queue from `index`
    *   Close
*   Close

### Process as a Setext primary heading

To [process as a Setext primary heading](#) is to perform the following steps:

*   Let `used` be the result of [process as Content][] with the [current
    group][] given hint *setext primary heading*
*   If `used`:

    *   Open a g:setext-heading-underline
    *   Emit
    *   Close twice
*   Otherwise:

    *   Let `index` be the position of the [current token][] in the queue
    *   If the [current token][] is a t:whitespace, remove `1` from `index`
    *   Open a g:content
    *   Emit the tokens before `index`
    *   Emit the tokens in the queue from `index` as a t:content

### Process as an asterisk line

To [process as an asterisk line](#) is to perform the following steps:

> ❗️ Delay for reference parser: This may be list item markers, list items with
> code, or content.
> It’s easier to figure this out with a reference parser that is tested.

### Process as an asterisk line opening

To [process as an asterisk line opening](#) is to perform the following steps:

> ❗️ Delay for reference parser: This may be list item markers, list items with
> code, or content.
> It’s easier to figure this out with a reference parser that is tested.

### Process as a Fenced code fence

To [process as a Fenced code fence](#) is to perform the following steps:

*   Let `fenceEnd` be `1`
*   Let `lineEnd` be the number of tokens in the queue
*   If the token in the queue before `lineEnd` is a t:whitespace, subtract `1`
    from `lineEnd`
*   If the token in the queue before `fenceEnd` is a t:whitespace, add `1` to
    `fenceEnd`
*   If `fenceEnd` is not `lineEnd` and the token in the queue at `fenceEnd` is a
    t:whitespace, add `1` to `fenceEnd`.
*   If `fenceEnd` is not `lineEnd`, let `langEnd` be `fenceEnd` plus `1`.
*   If `langEnd` points to a place and it is not `lineEnd`, let `metaStart` be
    `langEnd` plus `1`
*   Open a g:fenced-code-fence
*   Emit the tokens before `fenceEnd`
*   If `langEnd` points to a place:

    *   Let `lang` be a line without an ending where `start` is the start
        position of the token at `fenceEnd`, `end` is the end position of the
        token at `langEnd`
    *   Open a g:fenced-code-language
    *   [Process as plain text][] with `lines` set to a list with a single entry
        `lang`
    *   Close
*   If `metaStart` points to a place:

    *   Emit the token at `langEnd`
    *   Let `meta` be a line without an ending where `start` is the start
        position of the token at `metaStart`, `end` is the end position of the
        token at `lineEnd`
    *   Open a g:fenced-code-metadata
    *   [Process as plain text][] with `lines` set to a list with a single entry
        `meta`
    *   Close
*   If there is a token at `lineEnd`, emit it.
*   Close

### Process as Content

### Process as plain text

To [process as plain text](#) is to [process as Text][] given `lines` and `kind`
`plain`.

### Process as Phrasing

To [process as Phrasing](#) is to [process as Text][] given `lines`.

### Process as Text

## Tokens

### Whitespace token

A t:whitespace represents inline whitespace that is part of syntax instead
of content.

```idl
interface Whitespace <: Token {
  size: number
  used: number
  characters: [Character]
}
```

```js
{
  type: 'whitespace',
  characters: [9],
  size: 3,
  used: 0
}
```

### Line terminator token

A t:line-terminator represents a line break.

```idl
interface LineEnding <: Token {}
```

```js
{type: 'lineEnding'}
```

### End-of-file token

An t:end-of-file represents the end of the syntax.

```idl
interface EndOfFile <: Token {}
```

```js
{type: 'endOfFile'}
```

### End-of-line token

An t:end-of-line represents a point between two runs of text in content.

```idl
interface EndOfLine <: Token {}
```

```js
{type: 'endOfLine'}
```

### Marker token

A t:marker represents one punctuation character that is part of syntax instead
of content.

```idl
interface Marker <: Token {}
```

```js
{type: 'marker'}
```


### Sequence token

A t:sequence represents one or more of the same punctuation characters that are
part of syntax instead of content.


```idl
interface Sequence <: Token {
  size: number
}
```

```js
{type: 'sequence', size: 3}
```

### Content token

A t:content represents content.

```idl
interface Content <: Token {
  prefix: string
}
```

```js
{type: 'content', prefix: '  '}
```

## Groups

Groups are named groups of tokens and other blocks.

### Blank line group

A g:blank-line represents an empty line.

```idl
interface BlankLine <: Group {
  children: [Whitespace]
}
```

### ATX heading group

An g:atx-heading represents a heading for a section.

```idl
interface AtxHeading <: Group {
  children: [ATXHeadingFenceGroup | ATXHeadingContentGroup]
}
```

### ATX heading fence group

An g:atx-heading-fence represents a fence of a heading.

```idl
interface AtxHeadingFence <: Group {
  children: [Whitespace | Sequence]
}
```

### ATX heading content group

An g:atx-heading-content represents the phrasing of a heading.

```idl
interface AtxHeadingContent <: Group {
  children: [Phrasing]
}
```

### Thematic break group

A g:thematic-break represents a thematic break in a section.

```idl
interface ThematicBreak <: Group {
  children: [Sequence | Whitespace]
}
```

### HTML group

An g:html represents embedded HTML.

```idl
interface HTML <: Group {
  children: [HTMLineGroup | BlankLineGroup | LineEnding]
}
```

### HTML line group

An g:html-line represents a line of HTML.

```idl
interface HTMLLine <: Group {
  children: [Whitespace | Content]
}
```

### Indented code group

An g:indented-code represents preformatted text.

```idl
interface IndentedCode <: Group {
  children: [IndentedCodeLineGroup | BlankLineGroup | LineEnding]
}
```

### Indented code line group

An g:indented-code-line represents a line of indented code.

```idl
interface IndentedCodeLine <: Group {
  children: [Whitespace | Content]
}
```

### Blockquote group

A g:blockquote represents paraphrased text.

```idl
interface Blockquote <: Group {
  children: [FencedCodeGroup | IndentedCodeGroup | ATXHeadingGroup | SetextHeadingGroup | ThematicBreakGroup | HTMLGroup | ContentGroup | LineEnding]
}
```

### Fenced code group

A g:fenced-code represents preformatted text.

```idl
interface FencedCode <: Group {
  children: [FencedCodeFenceGroup | FencedCodeLineGroup | BlankLineGroup | LineEnding]
}
```

### Fenced code fence group

A g:fenced-code-fence represents a fence of fenced code.

```idl
interface FencedCodeFence <: Group {
  children: [Whitespace | Sequence | FencedCodeLanguageGroup | FencedCodeMetadataGroup]
}
```

### Fenced code language group

A g:fenced-code-language represents the programming language of fenced code.

```idl
interface FencedCodeLanguage <: Group {
  children: [EscapeGroup | CharacterReferenceGroup | Content]
}
```

### Fenced code metadata group

A g:fenced-code-metadata represents the metadata about fenced code.

```idl
interface FencedCodeMetadata <: Group {
  children: [EscapeGroup | CharacterReferenceGroup | Content | Whitespace]
}
```

### Fenced code line group

A g:fenced-code-line represents a line of fenced code.

```idl
interface FencedCodeLine <: Group {
  children: [Whitespace | Content]
}
```

### Content group

A g:content represents content: definitions, paragraphs, and sometimes heading
content.

```idl
interface Content <: Group {
  children: [ContentLineGroup | LineEnding]
}
```

### Content line group

A g:content-line represents a line of content.

```idl
interface ContentLine <: Group {
  children: [Whitespace | Content]
}
```

### Setext heading group

A g:setext-heading represents a heading for a section.

```idl
interface SetextHeading <: Group {
  children: [SetextHeadingContentGroup | SetextHeadingUnderlineGroup | LineEnding]
}
```

### Setext heading underline group

A g:setext-heading-underline represents a fence of a heading.

```idl
interface SetextHeadingUnderline <: Group {
  children: [Whitespace | Sequence]
}
```

### Definition group

A g:definition represents a link reference definition.

```idl
interface Definition <: Group {
  children: [DefinitionLabelGroup | DefinitionLabelQuotedGroup | DefinitionLabelUnquotedGroup | DefinitionTitleGroup | Whitespace | LineEnding]
}
```

### Definition label group

A g:definition-label represents the label of a definition.

```idl
interface DefinitionLabel <: Group {
  children: [DefinitionLabelContentGroup | Marker | Whitespace | LineEnding]
}
```

### Definition label content group

A g:definition-label-content represents the content of the label of a
definition.

```idl
interface DefinitionLabelContent <: Group {
  children: [EscapeGroup | CharacterReferenceGroup | Content | Whitespace | LineEnding]
}
```

### Definition destination quoted group

A g:definition-destination-quoted represents an enclosed destination of a
definition.

```idl
interface DefinitionDestinationQuoted <: Group {
  children: [EscapeGroup | CharacterReferenceGroup | Content | Marker]
}
```

### Definition destination unquoted group

A g:definition-destination-unquoted represents an unclosed destination of a
definition.

```idl
interface DefinitionDestinationUnquoted <: Group {
  children: [EscapeGroup | CharacterReferenceGroup | Content]
}
```

### Definition title group

A g:definition-title represents advisory information, such as a description of
the destination of the definition.

```idl
interface DefinitionTitle <: Group {
  children: [EscapeGroup | CharacterReferenceGroup | Content | Whitespace | LineEnding]
}
```

### Escape group

An g:escape represents an escaped marker or an empty escape.

```idl
interface Escape <: Group {
  children: [Marker | Content]
}
```

### Character reference group

A g:character-reference represents an escaped character.

```idl
interface CharacterReference <: Group {
  kind: name | hexadecimal | decimal
  children: [Marker | Content]
}
```

### Automatic link group

An g:automatic-link represents a literal URL or email address.

```idl
interface AutomaticLink <: Group {
  kind: email | uri
  children: [Marker | Content]
}
```

### HTML inline group

An g:html-inline represents XML-like structures.

```idl
interface HTMLInline <: Group {
  children: [Marker | Content | LineEnding]
}
```

## Appendix

### Raw tags

A [raw tag](#) is one of: `script`, `pre`, and `style`.

### Basic tags

A [basic tag](#) is one of: `address`, `article`, `aside`, `base`, `basefont`,
`blockquote`, `body`, `caption`, `center`, `col`, `colgroup`, `dd`, `details`,
`dialog`, `dir`, `div`, `dl`, `dt`, `fieldset`, `figcaption`, `figure`,
`footer`, `form`, `frame`, `frameset`, `h1`, `h2`, `h3`, `h4`, `h5`, `h6`,
`head`, `header`, `hr`, `html`, `iframe`, `legend`, `li`, `link`, `main`,
`menu`, `menuitem`, `nav`, `noframes`, `ol`, `optgroup`, `option`, `p`,
`param`, `section`, `source`, `summary`, `table`, `tbody`, `td`, `tfoot`, `th`,
`thead`, `title`, `tr`, `track`, and `ul`.

### Named character references

A [character reference name](#) is one of:
`AEli`, `AElig`, `AM`, `AMP`, `Aacut`, `Aacute`,
`Abreve`, `Acir`, `Acirc`, `Acy`, `Afr`, `Agrav`, `Agrave`, `Alpha`, `Amacr`,
`And`, `Aogon`, `Aopf`, `ApplyFunction`, `Arin`, `Aring`, `Ascr`, `Assign`,
`Atild`, `Atilde`, `Aum`, `Auml`, `Backslash`, `Barv`, `Barwed`, `Bcy`,
`Because`, `Bernoullis`, `Beta`, `Bfr`, `Bopf`, `Breve`, `Bscr`, `Bumpeq`,
`CHcy`, `COP`, `COPY`, `Cacute`, `Cap`, `CapitalDifferentialD`, `Cayleys`,
`Ccaron`, `Ccedi`, `Ccedil`, `Ccirc`, `Cconint`, `Cdot`, `Cedilla`, `CenterDot`,
`Cfr`, `Chi`, `CircleDot`, `CircleMinus`, `CirclePlus`, `CircleTimes`,
`ClockwiseContourIntegral`, `CloseCurlyDoubleQuote`, `CloseCurlyQuote`, `Colon`,
`Colone`, `Congruent`, `Conint`, `ContourIntegral`, `Copf`, `Coproduct`,
`CounterClockwiseContourIntegral`, `Cross`, `Cscr`, `Cup`, `CupCap`, `DD`,
`DDotrahd`, `DJcy`, `DScy`, `DZcy`, `Dagger`, `Darr`, `Dashv`, `Dcaron`, `Dcy`,
`Del`, `Delta`, `Dfr`, `DiacriticalAcute`, `DiacriticalDot`,
`DiacriticalDoubleAcute`, `DiacriticalGrave`, `DiacriticalTilde`, `Diamond`,
`DifferentialD`, `Dopf`, `Dot`, `DotDot`, `DotEqual`, `DoubleContourIntegral`,
`DoubleDot`, `DoubleDownArrow`, `DoubleLeftArrow`, `DoubleLeftRightArrow`,
`DoubleLeftTee`, `DoubleLongLeftArrow`, `DoubleLongLeftRightArrow`,
`DoubleLongRightArrow`, `DoubleRightArrow`, `DoubleRightTee`, `DoubleUpArrow`,
`DoubleUpDownArrow`, `DoubleVerticalBar`, `DownArrow`, `DownArrowBar`,
`DownArrowUpArrow`, `DownBreve`, `DownLeftRightVector`, `DownLeftTeeVector`,
`DownLeftVector`, `DownLeftVectorBar`, `DownRightTeeVector`, `DownRightVector`,
`DownRightVectorBar`, `DownTee`, `DownTeeArrow`, `Downarrow`, `Dscr`, `Dstrok`,
`ENG`, `ET`, `ETH`, `Eacut`, `Eacute`, `Ecaron`, `Ecir`, `Ecirc`, `Ecy`, `Edot`,
`Efr`, `Egrav`, `Egrave`, `Element`, `Emacr`, `EmptySmallSquare`,
`EmptyVerySmallSquare`, `Eogon`, `Eopf`, `Epsilon`, `Equal`, `EqualTilde`,
`Equilibrium`, `Escr`, `Esim`, `Eta`, `Eum`, `Euml`, `Exists`, `ExponentialE`,
`Fcy`, `Ffr`, `FilledSmallSquare`, `FilledVerySmallSquare`, `Fopf`, `ForAll`,
`Fouriertrf`, `Fscr`, `G`, `GJcy`, `GT`, `Gamma`, `Gammad`, `Gbreve`, `Gcedil`,
`Gcirc`, `Gcy`, `Gdot`, `Gfr`, `Gg`, `Gopf`, `GreaterEqual`, `GreaterEqualLess`,
`GreaterFullEqual`, `GreaterGreater`, `GreaterLess`, `GreaterSlantEqual`,
`GreaterTilde`, `Gscr`, `Gt`, `HARDcy`, `Hacek`, `Hat`, `Hcirc`, `Hfr`,
`HilbertSpace`, `Hopf`, `HorizontalLine`, `Hscr`, `Hstrok`, `HumpDownHump`,
`HumpEqual`, `IEcy`, `IJlig`, `IOcy`, `Iacut`, `Iacute`, `Icir`, `Icirc`, `Icy`,
`Idot`, `Ifr`, `Igrav`, `Igrave`, `Im`, `Imacr`, `ImaginaryI`, `Implies`, `Int`,
`Integral`, `Intersection`, `InvisibleComma`, `InvisibleTimes`, `Iogon`, `Iopf`,
`Iota`, `Iscr`, `Itilde`, `Iukcy`, `Ium`, `Iuml`, `Jcirc`, `Jcy`, `Jfr`, `Jopf`,
`Jscr`, `Jsercy`, `Jukcy`, `KHcy`, `KJcy`, `Kappa`, `Kcedil`, `Kcy`, `Kfr`,
`Kopf`, `Kscr`, `L`, `LJcy`, `LT`, `Lacute`, `Lambda`, `Lang`, `Laplacetrf`,
`Larr`, `Lcaron`, `Lcedil`, `Lcy`, `LeftAngleBracket`, `LeftArrow`,
`LeftArrowBar`, `LeftArrowRightArrow`, `LeftCeiling`, `LeftDoubleBracket`,
`LeftDownTeeVector`, `LeftDownVector`, `LeftDownVectorBar`, `LeftFloor`,
`LeftRightArrow`, `LeftRightVector`, `LeftTee`, `LeftTeeArrow`, `LeftTeeVector`,
`LeftTriangle`, `LeftTriangleBar`, `LeftTriangleEqual`, `LeftUpDownVector`,
`LeftUpTeeVector`, `LeftUpVector`, `LeftUpVectorBar`, `LeftVector`,
`LeftVectorBar`, `Leftarrow`, `Leftrightarrow`, `LessEqualGreater`,
`LessFullEqual`, `LessGreater`, `LessLess`, `LessSlantEqual`, `LessTilde`,
`Lfr`, `Ll`, `Lleftarrow`, `Lmidot`, `LongLeftArrow`, `LongLeftRightArrow`,
`LongRightArrow`, `Longleftarrow`, `Longleftrightarrow`, `Longrightarrow`,
`Lopf`, `LowerLeftArrow`, `LowerRightArrow`, `Lscr`, `Lsh`, `Lstrok`, `Lt`,
`Map`, `Mcy`, `MediumSpace`, `Mellintrf`, `Mfr`, `MinusPlus`, `Mopf`, `Mscr`,
`Mu`, `NJcy`, `Nacute`, `Ncaron`, `Ncedil`, `Ncy`, `NegativeMediumSpace`,
`NegativeThickSpace`, `NegativeThinSpace`, `NegativeVeryThinSpace`,
`NestedGreaterGreater`, `NestedLessLess`, `NewLine`, `Nfr`, `NoBreak`,
`NonBreakingSpace`, `Nopf`, `Not`, `NotCongruent`, `NotCupCap`,
`NotDoubleVerticalBar`, `NotElement`, `NotEqual`, `NotEqualTilde`, `NotExists`,
`NotGreater`, `NotGreaterEqual`, `NotGreaterFullEqual`, `NotGreaterGreater`,
`NotGreaterLess`, `NotGreaterSlantEqual`, `NotGreaterTilde`, `NotHumpDownHump`,
`NotHumpEqual`, `NotLeftTriangle`, `NotLeftTriangleBar`, `NotLeftTriangleEqual`,
`NotLess`, `NotLessEqual`, `NotLessGreater`, `NotLessLess`, `NotLessSlantEqual`,
`NotLessTilde`, `NotNestedGreaterGreater`, `NotNestedLessLess`, `NotPrecedes`,
`NotPrecedesEqual`, `NotPrecedesSlantEqual`, `NotReverseElement`,
`NotRightTriangle`, `NotRightTriangleBar`, `NotRightTriangleEqual`,
`NotSquareSubset`, `NotSquareSubsetEqual`, `NotSquareSuperset`,
`NotSquareSupersetEqual`, `NotSubset`, `NotSubsetEqual`, `NotSucceeds`,
`NotSucceedsEqual`, `NotSucceedsSlantEqual`, `NotSucceedsTilde`, `NotSuperset`,
`NotSupersetEqual`, `NotTilde`, `NotTildeEqual`, `NotTildeFullEqual`,
`NotTildeTilde`, `NotVerticalBar`, `Nscr`, `Ntild`, `Ntilde`, `Nu`, `OElig`,
`Oacut`, `Oacute`, `Ocir`, `Ocirc`, `Ocy`, `Odblac`, `Ofr`, `Ograv`, `Ograve`,
`Omacr`, `Omega`, `Omicron`, `Oopf`, `OpenCurlyDoubleQuote`, `OpenCurlyQuote`,
`Or`, `Oscr`, `Oslas`, `Oslash`, `Otild`, `Otilde`, `Otimes`, `Oum`, `Ouml`,
`OverBar`, `OverBrace`, `OverBracket`, `OverParenthesis`, `PartialD`, `Pcy`,
`Pfr`, `Phi`, `Pi`, `PlusMinus`, `Poincareplane`, `Popf`, `Pr`, `Precedes`,
`PrecedesEqual`, `PrecedesSlantEqual`, `PrecedesTilde`, `Prime`, `Product`,
`Proportion`, `Proportional`, `Pscr`, `Psi`, `QUO`, `QUOT`, `Qfr`, `Qopf`,
`Qscr`, `RBarr`, `RE`, `REG`, `Racute`, `Rang`, `Rarr`, `Rarrtl`, `Rcaron`,
`Rcedil`, `Rcy`, `Re`, `ReverseElement`, `ReverseEquilibrium`,
`ReverseUpEquilibrium`, `Rfr`, `Rho`, `RightAngleBracket`, `RightArrow`,
`RightArrowBar`, `RightArrowLeftArrow`, `RightCeiling`, `RightDoubleBracket`,
`RightDownTeeVector`, `RightDownVector`, `RightDownVectorBar`, `RightFloor`,
`RightTee`, `RightTeeArrow`, `RightTeeVector`, `RightTriangle`,
`RightTriangleBar`, `RightTriangleEqual`, `RightUpDownVector`,
`RightUpTeeVector`, `RightUpVector`, `RightUpVectorBar`, `RightVector`,
`RightVectorBar`, `Rightarrow`, `Ropf`, `RoundImplies`, `Rrightarrow`, `Rscr`,
`Rsh`, `RuleDelayed`, `SHCHcy`, `SHcy`, `SOFTcy`, `Sacute`, `Sc`, `Scaron`,
`Scedil`, `Scirc`, `Scy`, `Sfr`, `ShortDownArrow`, `ShortLeftArrow`,
`ShortRightArrow`, `ShortUpArrow`, `Sigma`, `SmallCircle`, `Sopf`, `Sqrt`,
`Square`, `SquareIntersection`, `SquareSubset`, `SquareSubsetEqual`,
`SquareSuperset`, `SquareSupersetEqual`, `SquareUnion`, `Sscr`, `Star`, `Sub`,
`Subset`, `SubsetEqual`, `Succeeds`, `SucceedsEqual`, `SucceedsSlantEqual`,
`SucceedsTilde`, `SuchThat`, `Sum`, `Sup`, `Superset`, `SupersetEqual`,
`Supset`, `THOR`, `THORN`, `TRADE`, `TSHcy`, `TScy`, `Tab`, `Tau`, `Tcaron`,
`Tcedil`, `Tcy`, `Tfr`, `Therefore`, `Theta`, `ThickSpace`, `ThinSpace`,
`Tilde`, `TildeEqual`, `TildeFullEqual`, `TildeTilde`, `Topf`, `TripleDot`,
`Tscr`, `Tstrok`, `Uacut`, `Uacute`, `Uarr`, `Uarrocir`, `Ubrcy`, `Ubreve`,
`Ucir`, `Ucirc`, `Ucy`, `Udblac`, `Ufr`, `Ugrav`, `Ugrave`, `Umacr`, `UnderBar`,
`UnderBrace`, `UnderBracket`, `UnderParenthesis`, `Union`, `UnionPlus`, `Uogon`,
`Uopf`, `UpArrow`, `UpArrowBar`, `UpArrowDownArrow`, `UpDownArrow`,
`UpEquilibrium`, `UpTee`, `UpTeeArrow`, `Uparrow`, `Updownarrow`,
`UpperLeftArrow`, `UpperRightArrow`, `Upsi`, `Upsilon`, `Uring`, `Uscr`,
`Utilde`, `Uum`, `Uuml`, `VDash`, `Vbar`, `Vcy`, `Vdash`, `Vdashl`, `Vee`,
`Verbar`, `Vert`, `VerticalBar`, `VerticalLine`, `VerticalSeparator`,
`VerticalTilde`, `VeryThinSpace`, `Vfr`, `Vopf`, `Vscr`, `Vvdash`, `Wcirc`,
`Wedge`, `Wfr`, `Wopf`, `Wscr`, `Xfr`, `Xi`, `Xopf`, `Xscr`, `YAcy`, `YIcy`,
`YUcy`, `Yacut`, `Yacute`, `Ycirc`, `Ycy`, `Yfr`, `Yopf`, `Yscr`, `Yuml`,
`ZHcy`, `Zacute`, `Zcaron`, `Zcy`, `Zdot`, `ZeroWidthSpace`, `Zeta`, `Zfr`,
`Zopf`, `Zscr`, `aacut`, `aacute`, `abreve`, `ac`, `acE`, `acd`, `acir`,
`acirc`, `acut`, `acute`, `acy`, `aeli`, `aelig`, `af`, `afr`, `agrav`,
`agrave`, `alefsym`, `aleph`, `alpha`, `am`, `amacr`, `amalg`, `amp`, `and`,
`andand`, `andd`, `andslope`, `andv`, `ang`, `ange`, `angle`, `angmsd`,
`angmsdaa`, `angmsdab`, `angmsdac`, `angmsdad`, `angmsdae`, `angmsdaf`,
`angmsdag`, `angmsdah`, `angrt`, `angrtvb`, `angrtvbd`, `angsph`, `angst`,
`angzarr`, `aogon`, `aopf`, `ap`, `apE`, `apacir`, `ape`, `apid`, `apos`,
`approx`, `approxeq`, `arin`, `aring`, `ascr`, `ast`, `asymp`, `asympeq`,
`atild`, `atilde`, `aum`, `auml`, `awconint`, `awint`, `bNot`, `backcong`,
`backepsilon`, `backprime`, `backsim`, `backsimeq`, `barvee`, `barwed`,
`barwedge`, `bbrk`, `bbrktbrk`, `bcong`, `bcy`, `bdquo`, `becaus`, `because`,
`bemptyv`, `bepsi`, `bernou`, `beta`, `beth`, `between`, `bfr`, `bigcap`,
`bigcirc`, `bigcup`, `bigodot`, `bigoplus`, `bigotimes`, `bigsqcup`, `bigstar`,
`bigtriangledown`, `bigtriangleup`, `biguplus`, `bigvee`, `bigwedge`, `bkarow`,
`blacklozenge`, `blacksquare`, `blacktriangle`, `blacktriangledown`,
`blacktriangleleft`, `blacktriangleright`, `blank`, `blk12`, `blk14`, `blk34`,
`block`, `bne`, `bnequiv`, `bnot`, `bopf`, `bot`, `bottom`, `bowtie`, `boxDL`,
`boxDR`, `boxDl`, `boxDr`, `boxH`, `boxHD`, `boxHU`, `boxHd`, `boxHu`, `boxUL`,
`boxUR`, `boxUl`, `boxUr`, `boxV`, `boxVH`, `boxVL`, `boxVR`, `boxVh`, `boxVl`,
`boxVr`, `boxbox`, `boxdL`, `boxdR`, `boxdl`, `boxdr`, `boxh`, `boxhD`, `boxhU`,
`boxhd`, `boxhu`, `boxminus`, `boxplus`, `boxtimes`, `boxuL`, `boxuR`, `boxul`,
`boxur`, `boxv`, `boxvH`, `boxvL`, `boxvR`, `boxvh`, `boxvl`, `boxvr`, `bprime`,
`breve`, `brvba`, `brvbar`, `bscr`, `bsemi`, `bsim`, `bsime`, `bsol`, `bsolb`,
`bsolhsub`, `bull`, `bullet`, `bump`, `bumpE`, `bumpe`, `bumpeq`, `cacute`,
`cap`, `capand`, `capbrcup`, `capcap`, `capcup`, `capdot`, `caps`, `caret`,
`caron`, `ccaps`, `ccaron`, `ccedi`, `ccedil`, `ccirc`, `ccups`, `ccupssm`,
`cdot`, `cedi`, `cedil`, `cemptyv`, `cen`, `cent`, `centerdot`, `cfr`, `chcy`,
`check`, `checkmark`, `chi`, `cir`, `cirE`, `circ`, `circeq`, `circlearrowleft`,
`circlearrowright`, `circledR`, `circledS`, `circledast`, `circledcirc`,
`circleddash`, `cire`, `cirfnint`, `cirmid`, `cirscir`, `clubs`, `clubsuit`,
`colon`, `colone`, `coloneq`, `comma`, `commat`, `comp`, `compfn`, `complement`,
`complexes`, `cong`, `congdot`, `conint`, `cop`, `copf`, `coprod`, `copy`,
`copysr`, `crarr`, `cross`, `cscr`, `csub`, `csube`, `csup`, `csupe`, `ctdot`,
`cudarrl`, `cudarrr`, `cuepr`, `cuesc`, `cularr`, `cularrp`, `cup`, `cupbrcap`,
`cupcap`, `cupcup`, `cupdot`, `cupor`, `cups`, `curarr`, `curarrm`,
`curlyeqprec`, `curlyeqsucc`, `curlyvee`, `curlywedge`, `curre`, `curren`,
`curvearrowleft`, `curvearrowright`, `cuvee`, `cuwed`, `cwconint`, `cwint`,
`cylcty`, `dArr`, `dHar`, `dagger`, `daleth`, `darr`, `dash`, `dashv`,
`dbkarow`, `dblac`, `dcaron`, `dcy`, `dd`, `ddagger`, `ddarr`, `ddotseq`, `de`,
`deg`, `delta`, `demptyv`, `dfisht`, `dfr`, `dharl`, `dharr`, `diam`, `diamond`,
`diamondsuit`, `diams`, `die`, `digamma`, `disin`, `div`, `divid`, `divide`,
`divideontimes`, `divonx`, `djcy`, `dlcorn`, `dlcrop`, `dollar`, `dopf`, `dot`,
`doteq`, `doteqdot`, `dotminus`, `dotplus`, `dotsquare`, `doublebarwedge`,
`downarrow`, `downdownarrows`, `downharpoonleft`, `downharpoonright`, `drbkarow`,
`drcorn`, `drcrop`, `dscr`, `dscy`, `dsol`, `dstrok`, `dtdot`, `dtri`, `dtrif`,
`duarr`, `duhar`, `dwangle`, `dzcy`, `dzigrarr`, `eDDot`, `eDot`, `eacut`,
`eacute`, `easter`, `ecaron`, `ecir`, `ecir`, `ecirc`, `ecolon`, `ecy`, `edot`,
`ee`, `efDot`, `efr`, `eg`, `egrav`, `egrave`, `egs`, `egsdot`, `el`,
`elinters`, `ell`, `els`, `elsdot`, `emacr`, `empty`, `emptyset`, `emptyv`,
`emsp`, `emsp13`, `emsp14`, `eng`, `ensp`, `eogon`, `eopf`, `epar`, `eparsl`,
`eplus`, `epsi`, `epsilon`, `epsiv`, `eqcirc`, `eqcolon`, `eqsim`, `eqslantgtr`,
`eqslantless`, `equals`, `equest`, `equiv`, `equivDD`, `eqvparsl`, `erDot`,
`erarr`, `escr`, `esdot`, `esim`, `et`, `eta`, `eth`, `eum`, `euml`, `euro`,
`excl`, `exist`, `expectation`, `exponentiale`, `fallingdotseq`, `fcy`,
`female`, `ffilig`, `fflig`, `ffllig`, `ffr`, `filig`, `fjlig`, `flat`, `fllig`,
`fltns`, `fnof`, `fopf`, `forall`, `fork`, `forkv`, `fpartint`, `frac1`,
`frac1`, `frac12`, `frac13`, `frac14`, `frac15`, `frac16`, `frac18`, `frac23`,
`frac25`, `frac3`, `frac34`, `frac35`, `frac38`, `frac45`, `frac56`, `frac58`,
`frac78`, `frasl`, `frown`, `fscr`, `g`, `gE`, `gEl`, `gacute`, `gamma`,
`gammad`, `gap`, `gbreve`, `gcirc`, `gcy`, `gdot`, `ge`, `gel`, `geq`, `geqq`,
`geqslant`, `ges`, `gescc`, `gesdot`, `gesdoto`, `gesdotol`, `gesl`, `gesles`,
`gfr`, `gg`, `ggg`, `gimel`, `gjcy`, `gl`, `glE`, `gla`, `glj`, `gnE`, `gnap`,
`gnapprox`, `gne`, `gneq`, `gneqq`, `gnsim`, `gopf`, `grave`, `gscr`, `gsim`,
`gsime`, `gsiml`, `gt`, `gtcc`, `gtcir`, `gtdot`, `gtlPar`, `gtquest`,
`gtrapprox`, `gtrarr`, `gtrdot`, `gtreqless`, `gtreqqless`, `gtrless`, `gtrsim`,
`gvertneqq`, `gvnE`, `hArr`, `hairsp`, `half`, `hamilt`, `hardcy`, `harr`,
`harrcir`, `harrw`, `hbar`, `hcirc`, `hearts`, `heartsuit`, `hellip`, `hercon`,
`hfr`, `hksearow`, `hkswarow`, `hoarr`, `homtht`, `hookleftarrow`,
`hookrightarrow`, `hopf`, `horbar`, `hscr`, `hslash`, `hstrok`, `hybull`,
`hyphen`, `iacut`, `iacute`, `ic`, `icir`, `icirc`, `icy`, `iecy`, `iexc`,
`iexcl`, `iff`, `ifr`, `igrav`, `igrave`, `ii`, `iiiint`, `iiint`, `iinfin`,
`iiota`, `ijlig`, `imacr`, `image`, `imagline`, `imagpart`, `imath`, `imof`,
`imped`, `in`, `incare`, `infin`, `infintie`, `inodot`, `int`, `intcal`,
`integers`, `intercal`, `intlarhk`, `intprod`, `iocy`, `iogon`, `iopf`, `iota`,
`iprod`, `iques`, `iquest`, `iscr`, `isin`, `isinE`, `isindot`, `isins`,
`isinsv`, `isinv`, `it`, `itilde`, `iukcy`, `ium`, `iuml`, `jcirc`, `jcy`,
`jfr`, `jmath`, `jopf`, `jscr`, `jsercy`, `jukcy`, `kappa`, `kappav`, `kcedil`,
`kcy`, `kfr`, `kgreen`, `khcy`, `kjcy`, `kopf`, `kscr`, `l`, `lAarr`, `lArr`,
`lAtail`, `lBarr`, `lE`, `lEg`, `lHar`, `lacute`, `laemptyv`, `lagran`,
`lambda`, `lang`, `langd`, `langle`, `lap`, `laqu`, `laquo`, `larr`, `larrb`,
`larrbfs`, `larrfs`, `larrhk`, `larrlp`, `larrpl`, `larrsim`, `larrtl`, `lat`,
`latail`, `late`, `lates`, `lbarr`, `lbbrk`, `lbrace`, `lbrack`, `lbrke`,
`lbrksld`, `lbrkslu`, `lcaron`, `lcedil`, `lceil`, `lcub`, `lcy`, `ldca`,
`ldquo`, `ldquor`, `ldrdhar`, `ldrushar`, `ldsh`, `le`, `leftarrow`,
`leftarrowtail`, `leftharpoondown`, `leftharpoonup`, `leftleftarrows`,
`leftrightarrow`, `leftrightarrows`, `leftrightharpoons`, `leftrightsquigarrow`,
`leftthreetimes`, `leg`, `leq`, `leqq`, `leqslant`, `les`, `lescc`, `lesdot`,
`lesdoto`, `lesdotor`, `lesg`, `lesges`, `lessapprox`, `lessdot`, `lesseqgtr`,
`lesseqqgtr`, `lessgtr`, `lesssim`, `lfisht`, `lfloor`, `lfr`, `lg`, `lgE`,
`lhard`, `lharu`, `lharul`, `lhblk`, `ljcy`, `ll`, `llarr`, `llcorner`,
`llhard`, `lltri`, `lmidot`, `lmoust`, `lmoustache`, `lnE`, `lnap`, `lnapprox`,
`lne`, `lneq`, `lneqq`, `lnsim`, `loang`, `loarr`, `lobrk`, `longleftarrow`,
`longleftrightarrow`, `longmapsto`, `longrightarrow`, `looparrowleft`,
`looparrowright`, `lopar`, `lopf`, `loplus`, `lotimes`, `lowast`, `lowbar`,
`loz`, `lozenge`, `lozf`, `lpar`, `lparlt`, `lrarr`, `lrcorner`, `lrhar`,
`lrhard`, `lrm`, `lrtri`, `lsaquo`, `lscr`, `lsh`, `lsim`, `lsime`, `lsimg`,
`lsqb`, `lsquo`, `lsquor`, `lstrok`, `lt`, `ltcc`, `ltcir`, `ltdot`, `lthree`,
`ltimes`, `ltlarr`, `ltquest`, `ltrPar`, `ltri`, `ltrie`, `ltrif`, `lurdshar`,
`luruhar`, `lvertneqq`, `lvnE`, `mDDot`, `mac`, `macr`, `male`, `malt`,
`maltese`, `map`, `mapsto`, `mapstodown`, `mapstoleft`, `mapstoup`, `marker`,
`mcomma`, `mcy`, `mdash`, `measuredangle`, `mfr`, `mho`, `micr`, `micro`,
`mid`, `midast`, `midcir`, `middo`, `middot`, `minus`, `minusb`, `minusd`,
`minusdu`, `mlcp`, `mldr`, `mnplus`, `models`, `mopf`, `mp`, `mscr`, `mstpos`,
`mu`, `multimap`, `mumap`, `nGg`, `nGt`, `nGtv`, `nLeftarrow`,
`nLeftrightarrow`, `nLl`, `nLt`, `nLtv`, `nRightarrow`, `nVDash`, `nVdash`,
`nabla`, `nacute`, `nang`, `nap`, `napE`, `napid`, `napos`, `napprox`, `natur`,
`natural`, `naturals`, `nbs`, `nbsp`, `nbump`, `nbumpe`, `ncap`, `ncaron`,
`ncedil`, `ncong`, `ncongdot`, `ncup`, `ncy`, `ndash`, `ne`, `neArr`, `nearhk`,
`nearr`, `nearrow`, `nedot`, `nequiv`, `nesear`, `nesim`, `nexist`, `nexists`,
`nfr`, `ngE`, `nge`, `ngeq`, `ngeqq`, `ngeqslant`, `nges`, `ngsim`, `ngt`,
`ngtr`, `nhArr`, `nharr`, `nhpar`, `ni`, `nis`, `nisd`, `niv`, `njcy`, `nlArr`,
`nlE`, `nlarr`, `nldr`, `nle`, `nleftarrow`, `nleftrightarrow`, `nleq`,
`nleqq`, `nleqslant`, `nles`, `nless`, `nlsim`, `nlt`, `nltri`, `nltrie`,
`nmid`, `no`, `nopf`, `not`, `notin`, `notinE`, `notindot`, `notinva`,
`notinvb`, `notinvc`, `notni`, `notniva`, `notnivb`, `notnivc`, `npar`,
`nparallel`, `nparsl`, `npart`, `npolint`, `npr`, `nprcue`, `npre`, `nprec`,
`npreceq`, `nrArr`, `nrarr`, `nrarrc`, `nrarrw`, `nrightarrow`, `nrtri`,
`nrtrie`, `nsc`, `nsccue`, `nsce`, `nscr`, `nshortmid`, `nshortparallel`,
`nsim`, `nsime`, `nsimeq`, `nsmid`, `nspar`, `nsqsube`, `nsqsupe`, `nsub`,
`nsubE`, `nsube`, `nsubset`, `nsubseteq`, `nsubseteqq`, `nsucc`, `nsucceq`,
`nsup`, `nsupE`, `nsupe`, `nsupset`, `nsupseteq`, `nsupseteqq`, `ntgl`, `ntild`,
`ntilde`, `ntlg`, `ntriangleleft`, `ntrianglelefteq`, `ntriangleright`,
`ntrianglerighteq`, `nu`, `num`, `numero`, `numsp`, `nvDash`, `nvHarr`, `nvap`,
`nvdash`, `nvge`, `nvgt`, `nvinfin`, `nvlArr`, `nvle`, `nvlt`, `nvltrie`,
`nvrArr`, `nvrtrie`, `nvsim`, `nwArr`, `nwarhk`, `nwarr`, `nwarrow`, `nwnear`,
`oS`, `oacut`, `oacute`, `oast`, `ocir`, `ocir`, `ocirc`, `ocy`, `odash`,
`odblac`, `odiv`, `odot`, `odsold`, `oelig`, `ofcir`, `ofr`, `ogon`, `ograv`,
`ograve`, `ogt`, `ohbar`, `ohm`, `oint`, `olarr`, `olcir`, `olcross`, `oline`,
`olt`, `omacr`, `omega`, `omicron`, `omid`, `ominus`, `oopf`, `opar`, `operp`,
`oplus`, `or`, `orarr`, `ord`, `ord`, `ord`, `order`, `orderof`, `ordf`, `ordm`,
`origof`, `oror`, `orslope`, `orv`, `oscr`, `oslas`, `oslash`, `osol`, `otild`,
`otilde`, `otimes`, `otimesas`, `oum`, `ouml`, `ovbar`, `par`, `par`, `para`,
`parallel`, `parsim`, `parsl`, `part`, `pcy`, `percnt`, `period`, `permil`,
`perp`, `pertenk`, `pfr`, `phi`, `phiv`, `phmmat`, `phone`, `pi`, `pitchfork`,
`piv`, `planck`, `planckh`, `plankv`, `plus`, `plusacir`, `plusb`, `pluscir`,
`plusdo`, `plusdu`, `pluse`, `plusm`, `plusmn`, `plussim`, `plustwo`, `pm`,
`pointint`, `popf`, `poun`, `pound`, `pr`, `prE`, `prap`, `prcue`, `pre`,
`prec`, `precapprox`, `preccurlyeq`, `preceq`, `precnapprox`, `precneqq`,
`precnsim`, `precsim`, `prime`, `primes`, `prnE`, `prnap`, `prnsim`, `prod`,
`profalar`, `profline`, `profsurf`, `prop`, `propto`, `prsim`, `prurel`, `pscr`,
`psi`, `puncsp`, `qfr`, `qint`, `qopf`, `qprime`, `qscr`, `quaternions`,
`quatint`, `quest`, `questeq`, `quo`, `quot`, `rAarr`, `rArr`, `rAtail`,
`rBarr`, `rHar`, `race`, `racute`, `radic`, `raemptyv`, `rang`, `rangd`,
`range`, `rangle`, `raqu`, `raquo`, `rarr`, `rarrap`, `rarrb`, `rarrbfs`,
`rarrc`, `rarrfs`, `rarrhk`, `rarrlp`, `rarrpl`, `rarrsim`, `rarrtl`, `rarrw`,
`ratail`, `ratio`, `rationals`, `rbarr`, `rbbrk`, `rbrace`, `rbrack`, `rbrke`,
`rbrksld`, `rbrkslu`, `rcaron`, `rcedil`, `rceil`, `rcub`, `rcy`, `rdca`,
`rdldhar`, `rdquo`, `rdquor`, `rdsh`, `re`, `real`, `realine`, `realpart`,
`reals`, `rect`, `reg`, `rfisht`, `rfloor`, `rfr`, `rhard`, `rharu`, `rharul`,
`rho`, `rhov`, `rightarrow`, `rightarrowtail`, `rightharpoondown`,
`rightharpoonup`, `rightleftarrows`, `rightleftharpoons`, `rightrightarrows`,
`rightsquigarrow`, `rightthreetimes`, `ring`, `risingdotseq`, `rlarr`, `rlhar`,
`rlm`, `rmoust`, `rmoustache`, `rnmid`, `roang`, `roarr`, `robrk`, `ropar`,
`ropf`, `roplus`, `rotimes`, `rpar`, `rpargt`, `rppolint`, `rrarr`, `rsaquo`,
`rscr`, `rsh`, `rsqb`, `rsquo`, `rsquor`, `rthree`, `rtimes`, `rtri`, `rtrie`,
`rtrif`, `rtriltri`, `ruluhar`, `rx`, `sacute`, `sbquo`, `sc`, `scE`, `scap`,
`scaron`, `sccue`, `sce`, `scedil`, `scirc`, `scnE`, `scnap`, `scnsim`,
`scpolint`, `scsim`, `scy`, `sdot`, `sdotb`, `sdote`, `seArr`, `searhk`,
`searr`, `searrow`, `sec`, `sect`, `semi`, `seswar`, `setminus`, `setmn`,
`sext`, `sfr`, `sfrown`, `sh`, `sharp`, `shchcy`, `shcy`, `shortmid`,
`shortparallel`, `shy`, `sigma`, `sigmaf`, `sigmav`, `sim`, `simdot`, `sime`,
`simeq`, `simg`, `simgE`, `siml`, `simlE`, `simne`, `simplus`, `simrarr`,
`slarr`, `smallsetminus`, `smashp`, `smeparsl`, `smid`, `smile`, `smt`, `smte`,
`smtes`, `softcy`, `sol`, `solb`, `solbar`, `sopf`, `spades`, `spadesuit`,
`spar`, `sqcap`, `sqcaps`, `sqcup`, `sqcups`, `sqsub`, `sqsube`, `sqsubset`,
`sqsubseteq`, `sqsup`, `sqsupe`, `sqsupset`, `sqsupseteq`, `squ`, `square`,
`squarf`, `squf`, `srarr`, `sscr`, `ssetmn`, `ssmile`, `sstarf`, `star`,
`starf`, `straightepsilon`, `straightphi`, `strns`, `sub`, `subE`, `subdot`,
`sube`, `subedot`, `submult`, `subnE`, `subne`, `subplus`, `subrarr`, `subset`,
`subseteq`, `subseteqq`, `subsetneq`, `subsetneqq`, `subsim`, `subsub`,
`subsup`, `succ`, `succapprox`, `succcurlyeq`, `succeq`, `succnapprox`,
`succneqq`, `succnsim`, `succsim`, `sum`, `sung`, `sup`, `sup`, `sup`, `sup`,
`sup1`, `sup2`, `sup3`, `supE`, `supdot`, `supdsub`, `supe`, `supedot`,
`suphsol`, `suphsub`, `suplarr`, `supmult`, `supnE`, `supne`, `supplus`,
`supset`, `supseteq`, `supseteqq`, `supsetneq`, `supsetneqq`, `supsim`,
`supsub`, `supsup`, `swArr`, `swarhk`, `swarr`, `swarrow`, `swnwar`, `szli`,
`szlig`, `target`, `tau`, `tbrk`, `tcaron`, `tcedil`, `tcy`, `tdot`, `telrec`,
`tfr`, `there4`, `therefore`, `theta`, `thetasym`, `thetav`, `thickapprox`,
`thicksim`, `thinsp`, `thkap`, `thksim`, `thor`, `thorn`, `tilde`, `time`,
`times`, `timesb`, `timesbar`, `timesd`, `tint`, `toea`, `top`, `topbot`,
`topcir`, `topf`, `topfork`, `tosa`, `tprime`, `trade`, `triangle`,
`triangledown`, `triangleleft`, `trianglelefteq`, `triangleq`, `triangleright`,
`trianglerighteq`, `tridot`, `trie`, `triminus`, `triplus`, `trisb`, `tritime`,
`trpezium`, `tscr`, `tscy`, `tshcy`, `tstrok`, `twixt`, `twoheadleftarrow`,
`twoheadrightarrow`, `uArr`, `uHar`, `uacut`, `uacute`, `uarr`, `ubrcy`,
`ubreve`, `ucir`, `ucirc`, `ucy`, `udarr`, `udblac`, `udhar`, `ufisht`, `ufr`,
`ugrav`, `ugrave`, `uharl`, `uharr`, `uhblk`, `ulcorn`, `ulcorner`, `ulcrop`,
`ultri`, `um`, `umacr`, `uml`, `uogon`, `uopf`, `uparrow`, `updownarrow`,
`upharpoonleft`, `upharpoonright`, `uplus`, `upsi`, `upsih`, `upsilon`,
`upuparrows`, `urcorn`, `urcorner`, `urcrop`, `uring`, `urtri`, `uscr`, `utdot`,
`utilde`, `utri`, `utrif`, `uuarr`, `uum`, `uuml`, `uwangle`, `vArr`, `vBar`,
`vBarv`, `vDash`, `vangrt`, `varepsilon`, `varkappa`, `varnothing`, `varphi`,
`varpi`, `varpropto`, `varr`, `varrho`, `varsigma`, `varsubsetneq`,
`varsubsetneqq`, `varsupsetneq`, `varsupsetneqq`, `vartheta`, `vartriangleleft`,
`vartriangleright`, `vcy`, `vdash`, `vee`, `veebar`, `veeeq`, `vellip`,
`verbar`, `vert`, `vfr`, `vltri`, `vnsub`, `vnsup`, `vopf`, `vprop`, `vrtri`,
`vscr`, `vsubnE`, `vsubne`, `vsupnE`, `vsupne`, `vzigzag`, `wcirc`, `wedbar`,
`wedge`, `wedgeq`, `weierp`, `wfr`, `wopf`, `wp`, `wr`, `wreath`, `wscr`,
`xcap`, `xcirc`, `xcup`, `xdtri`, `xfr`, `xhArr`, `xharr`, `xi`, `xlArr`,
`xlarr`, `xmap`, `xnis`, `xodot`, `xopf`, `xoplus`, `xotime`, `xrArr`, `xrarr`,
`xscr`, `xsqcup`, `xuplus`, `xutri`, `xvee`, `xwedge`, `yacut`, `yacute`,
`yacy`, `ycirc`, `ycy`, `ye`, `yen`, `yfr`, `yicy`, `yopf`, `yscr`, `yucy`,
`yum`, `yuml`, `zacute`, `zcaron`, `zcy`, `zdot`, `zeetrf`, `zeta`, `zfr`,
`zhcy`, `zigrarr`, `zopf`, `zscr`, `zwj`, or `zwnj`.

## References

*   **\[HTML]**:
    [HTML Standard](https://html.spec.whatwg.org/multipage/).
    A. van Kesteren, et al.
    WHATWG.
*   **\[RFC20]**:
    [ASCII format for network interchange](https://tools.ietf.org/html/rfc20).
    V.G. Cerf.
    October 1969.
    IETF.
*   **\[RFC5322]**:
    [Internet Message Format](https://tools.ietf.org/html/rfc5322).
    P. Resnick.
    IETF.
*   **\[UNICODE]**:
    [The Unicode Standard](https://www.unicode.org/versions/).
    Unicode Consortium.

## Acknowledgments

Thanks to John Gruber for inventing Markdown.

Thanks to John MacFarlane for defining CommonMark.

Thanks to ZEIT, Inc., Gatsby, Inc., Netlify, Inc., Holloway, Inc., and the many
organizations and individuals for financial support through
[OpenCollective](https://opencollective.com/unified)

## License

Copyright © 2019 Titus Wormer.
This work is licensed under a
[Creative Commons Attribution 4.0 International License](https://creativecommons.org/licenses/by/4.0/).
